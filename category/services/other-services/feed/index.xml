<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:wfw="http://wellformedweb.org/CommentAPI/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	xmlns:slash="http://purl.org/rss/1.0/modules/slash/"
	>

<channel>
	<title>Other Services (其他服务) &#8211; Eternal Center</title>
	<atom:link href="https://eternalcenter-2022-02.github.io/category/services/other-services/feed/" rel="self" type="application/rss+xml" />
	<link>https://eternalcenter-2022-02.github.io/</link>
	<description></description>
	<lastBuildDate>Thu, 03 Feb 2022 12:41:42 +0000</lastBuildDate>
	<language>en-US</language>
	<sy:updatePeriod>
	hourly	</sy:updatePeriod>
	<sy:updateFrequency>
	1	</sy:updateFrequency>
	
	<item>
		<title>[STEP] Redhat Satellite client register</title>
		<link>https://eternalcenter-2022-02.github.io/step-redhat-satellite-client-register/</link>
		
		<dc:creator><![CDATA[Mingyu Zhu]]></dc:creator>
		<pubDate>Tue, 18 Jan 2022 14:41:36 +0000</pubDate>
				<category><![CDATA[English (英文)]]></category>
		<category><![CDATA[Other Services (其他服务)]]></category>
		<category><![CDATA[Red Hat Satellite]]></category>
		<category><![CDATA[Services (服务)]]></category>
		<guid isPermaLink="false">https://eternalcenter-2022-02.github.io/?p=21287</guid>

					<description><![CDATA[Step One: Add domain name resolution into /etc/hosts Add the following: Step Two: Install katello-ca-consumer-latest.noarch.rpm2.1 Download katello-ca-consumer-latest.noarch.rpm 2.2 Install katello-ca-consumer-latest.noarch.rpm Step Three: Register to Redhat Satellite Server Step Four: Install katello-host-tools, katello-host-tools-tracer and katello-agent4.1 Enable rhel-*-satellite-tools-*-rpms repo or satellite-tools-*-rhel-*-rpms4.1.1 For RHEL 7 4.1.2 For RHEL 8 4.2 Install katello-host-tools, katello-host-tools-tracer and katello-agent Step Five: Check5.1 &#8230; <p class="link-more"><a href="https://eternalcenter-2022-02.github.io/step-redhat-satellite-client-register/" class="more-link">Continue reading<span class="screen-reader-text"> "[STEP] Redhat Satellite client register"</span></a></p>]]></description>
										<content:encoded><![CDATA[
<h4>Step One: Add domain name resolution into /etc/hosts</h4>



<pre class="wp-block-code"><code># vim /etc/hosts</code></pre>



<p>Add the following:</p>



<pre class="wp-block-code"><code>......
&lt;Redhat Satellite IP address&gt; &lt;Redhat Satellite Server FQDN&gt;</code></pre>



<h4>Step Two: Install katello-ca-consumer-latest.noarch.rpm<br>2.1 Download katello-ca-consumer-latest.noarch.rpm</h4>



<pre class="wp-block-code"><code># curl --insecure --output katello-ca-consumer-latest.noarch.rpm https://&lt;Redhat/ Satellite Server FQDN&gt;/pub/katello-ca-consumer-latest.noarch.rpm</code></pre>



<h4>2.2 Install katello-ca-consumer-latest.noarch.rpm</h4>



<pre class="wp-block-code"><code># yum -y localinstall katello-ca-consumer-latest.noarch.rpm</code></pre>



<h4>Step Three: Register to Redhat Satellite Server</h4>



<pre class="wp-block-code"><code># subscription-manager register --org="&lt;organization&gt;" --activationkey="&lt;activation key&gt;"</code></pre>



<h4>Step Four: Install katello-host-tools, katello-host-tools-tracer and katello-agent<br>4.1 Enable rhel-*-satellite-tools-*-rpms repo or satellite-tools-*-rhel-*-rpms<br>4.1.1 For RHEL 7</h4>



<pre class="wp-block-code"><code># subscription-manager repos --enable=rhel-\*-satellite-tools-\*-rpms</code></pre>



<h4>4.1.2 For RHEL 8</h4>



<pre class="wp-block-code"><code># subscription-manager repos --enable=satellite-tools-\*-rhel-\*-rpms
# subscription-manager repos --disable=satellite-tools-\*-rhel-\*-eus-rpms</code></pre>



<h4>4.2 Install katello-host-tools, katello-host-tools-tracer and katello-agent</h4>



<pre class="wp-block-code"><code># yum -y install katello-host-tools; yum -y install katello-host-tools-tracer; yum -y install katello-agent</code></pre>



<h4>Step Five: Check<br>5.1 Check registration information</h4>



<pre class="wp-block-code"><code># subscription-manager identity</code></pre>



<h4>5.2 Check license</h4>



<pre class="wp-block-code"><code># subscription-manager list --consumed</code></pre>
]]></content:encoded>
					
		
		
			</item>
		<item>
		<title>[步骤] Red Hat Satellite Server 客户端注册的取消</title>
		<link>https://eternalcenter-2022-02.github.io/red-hat-satellite-server-client-unregister/</link>
		
		<dc:creator><![CDATA[Mingyu Zhu]]></dc:creator>
		<pubDate>Tue, 18 Jan 2022 13:54:51 +0000</pubDate>
				<category><![CDATA[Chinese (中文)]]></category>
		<category><![CDATA[Other Services (其他服务)]]></category>
		<category><![CDATA[Red Hat Satellite]]></category>
		<category><![CDATA[Services (服务)]]></category>
		<guid isPermaLink="false">https://eternalcenter-2022-02.github.io/?p=21280</guid>

					<description><![CDATA[步骤一：取消 Red Hat Satellite Server 客户端的注册 步骤二：清理 Red Hat Satellite Server 客户端的注册信息]]></description>
										<content:encoded><![CDATA[
<h4>步骤一：取消 Red Hat Satellite Server 客户端的注册</h4>



<pre class="wp-block-code"><code># subscription-manager unregister</code></pre>



<h4>步骤二：清理 Red Hat Satellite Server 客户端的注册信息 </h4>



<pre class="wp-block-code"><code># subscription-manager clean</code></pre>
]]></content:encoded>
					
		
		
			</item>
		<item>
		<title>[步骤] GitHub 代码的更新 （令牌版）</title>
		<link>https://eternalcenter-2022-02.github.io/github-push-token/</link>
		
		<dc:creator><![CDATA[Mingyu Zhu]]></dc:creator>
		<pubDate>Sat, 01 Jan 2022 13:33:23 +0000</pubDate>
				<category><![CDATA[Chinese (中文)]]></category>
		<category><![CDATA[Git]]></category>
		<category><![CDATA[Other Services (其他服务)]]></category>
		<category><![CDATA[Services (服务)]]></category>
		<guid isPermaLink="false">https://eternalcenter-2022-02.github.io/?p=20763</guid>

					<description><![CDATA[步骤目录： 步骤一：在 GitHub 官网上生成令牌1.1 在 https://github.com/ 上登录或注册 GitHub 用户1.2 在 GitHub 上创建仓库1.3 在 GitHub 官网上生成令牌1.4 复制生成的令牌 步骤二：更新 GitHub 代码2.1 进入有代码需要更新的目录2.2 初始化 Git 环境2.3 添加需要更新的代码2.4 提交刚刚的添加2.5 创建或选择代码库的分支2.6 添加 GitHub 源2.7 通过令牌设置 GitHub 源2.8 将代码更新至 GitHub 具体的操作步骤： 步骤一：在 GitHub 官网上生成令牌1.1 在 https://github.com/ 上登录或注册 GitHub 用户 （步骤略） 1.2 在 GitHub 上创建仓库 右上角 + &#8211;&#62; New repository &#8211;&#62; 填写 &#8230; <p class="link-more"><a href="https://eternalcenter-2022-02.github.io/github-push-token/" class="more-link">Continue reading<span class="screen-reader-text"> "[步骤] GitHub 代码的更新 （令牌版）"</span></a></p>]]></description>
										<content:encoded><![CDATA[
<h2>步骤目录：</h2>



<h4>步骤一：在 GitHub 官网上生成令牌<br>1.1 在 https://github.com/ 上登录或注册 GitHub 用户<br>1.2 在 GitHub 上创建仓库<br>1.3 在 GitHub 官网上生成令牌<br>1.4 复制生成的令牌</h4>



<h4>步骤二：更新 GitHub 代码<br>2.1 进入有代码需要更新的目录<br>2.2 初始化 Git 环境<br>2.3 添加需要更新的代码<br>2.4 提交刚刚的添加<br>2.5 创建或选择代码库的分支<br>2.6 添加 GitHub 源<br>2.7 通过令牌设置 GitHub 源<br>2.8 将代码更新至 GitHub</h4>



<h2>具体的操作步骤：</h2>



<h4>步骤一：在 GitHub 官网上生成令牌<br>1.1 在 https://github.com/ 上登录或注册 GitHub 用户</h4>



<p>（步骤略）</p>



<h4>1.2 在 GitHub 上创建仓库</h4>



<p>右上角 + &#8211;&gt; New repository &#8211;&gt; 填写 Repository name &#8211;&gt; 勾选 Public &#8211;&gt; Create repository</p>



<p>（注意：只有当要使用的仓库还没有创建时才需要进行此步骤）</p>



<h4>1.3 在 GitHub 官网上生成令牌</h4>



<p>右上角的头像 &#8211;&gt; Settings &#8211;&gt; Developer settings &#8211;&gt; Personal access tokens &#8211;&gt; Generate new token &#8211;&gt; 勾选需要的 scopes &#8211;&gt; Generate token</p>



<h4>1.4 复制生成的令牌</h4>



<p>（步骤略）</p>



<h4>步骤二：更新 GitHub 代码<br>2.1 进入有代码需要更新的目录</h4>



<pre class="wp-block-code"><code># cd github</code></pre>



<p>（补充：这里以进入 github 目录为例）</p>



<h4>2.2 初始化 Git 环境</h4>



<pre class="wp-block-code"><code># git init</code></pre>



<h4>2.3 添加需要更新的代码</h4>



<pre class="wp-block-code"><code># git add *</code></pre>



<p>（补充：这里以添加当前目录下的所有文件为例）</p>



<h4>2.4 提交刚刚的添加</h4>



<pre class="wp-block-code"><code># git commit -m "last commit"</code></pre>



<p>（补充：这里以提交时添加 “last commit” 备注为例）</p>



<h4>2.5 创建或选择代码库的分支</h4>



<pre class="wp-block-code"><code># git branch -M main</code></pre>



<p>（补充：这里以创建或选择库里的 main 分支为例）</p>



<h4>2.6 添加 GitHub 源</h4>



<pre class="wp-block-code"><code># git remote add origin git@github.com:eternalcenter-now/eternalcenter-now.github.io.git</code></pre>



<p>（补充：这里以添加 GitHub 的 eternalcenter-now 用户的 eternalcenter-now.github.io.git 库为例）</p>



<p>（注意：这里的 eternalcenter-now 用户和 eternalcenter-now.github.io.git 库是指在 1.1、1.2 上创建的用户和库）</p>



<h4>2.7 通过令牌设置 GitHub 源</h4>



<pre class="wp-block-code"><code># git remote set-url origin https://gafafhp_Nfaodfwiixma8hPpds4e6asdflim@github.com/eternalcenter-now/eternalcenter-now.github.io.git</code></pre>



<p>（补充：这里以使用 GitHub 的 gafafhp_Nfaodfwiixma8hPpds4e6asdflim 令牌、eternalcenter-now 用户的 eternalcenter-now.github.io.git 库为例）</p>



<p>（注意：这里的 eternalcenter-now 用户、eternalcenter-now.github.io.git 库和 gafafhp_Nfaodfwiixma8hPpds4e6asdflim 令牌是指在 1.1、1.2、1.3 上创建的用户、库和生成的令牌）</p>



<h4>2.8 将代码更新至 GitHub</h4>



<pre class="wp-block-code"><code># git push -u origin main</code></pre>



<p>（补充：这里以将代码更新至 main 分支为例）</p>
]]></content:encoded>
					
		
		
			</item>
		<item>
		<title>[工具] Shell 将同目录下最新的某个目录里的所有文件替换到 GitHub 库里 （Git LFS 版）</title>
		<link>https://eternalcenter-2022-02.github.io/shell-github-replace-git-lfs/</link>
		
		<dc:creator><![CDATA[Mingyu Zhu]]></dc:creator>
		<pubDate>Sat, 18 Dec 2021 13:44:56 +0000</pubDate>
				<category><![CDATA[Chinese (中文)]]></category>
		<category><![CDATA[Git]]></category>
		<category><![CDATA[Languages (语言)]]></category>
		<category><![CDATA[Other Services (其他服务)]]></category>
		<category><![CDATA[Services (服务)]]></category>
		<category><![CDATA[Shell]]></category>
		<category><![CDATA[Shell Backup (备份)]]></category>
		<category><![CDATA[Shell Tool (工具)]]></category>
		<guid isPermaLink="false">https://eternalcenter-2022-02.github.io/?p=19851</guid>

					<description><![CDATA[介绍： 作者：朱明宇名称：将同目录下最新的某个目录里的所有文件替换到 GitHub 库里作用：将同目录下最新的某个目录里的所有文件替换到 GitHub 库里 使用方法：1. 在此脚本的分割线内写入相应的内容2. 给此脚本添加执行权限3. 执行此脚本 脚本分割线里的变量：1. directory=download-eternalcenter #本地的缓冲目录2. gituser=mingyuzhu #GitHub 用户3. gitemail=mingyu.zhu@eternalcenter.com #GitHub 邮箱4. gitrepository=download-eternalcenter #GitHub 库5. gitbranch=’master’ #GitHub 库的分支6. backupfile=all #备份后的文件7. keyword=clone #同目录下要备份目录名称的关键字 注意：需要提前安装 git 和 git-lfs，注册 GitHub，创建相应的 GitHub 库，并且创建和设置了对应的 ssh 密钥 脚本：]]></description>
										<content:encoded><![CDATA[
<h2>介绍：</h2>



<p>作者：朱明宇<br>名称：将同目录下最新的某个目录里的所有文件替换到 GitHub 库里<br>作用：将同目录下最新的某个目录里的所有文件替换到 GitHub 库里</p>



<p>使用方法：<br>1. 在此脚本的分割线内写入相应的内容<br>2. 给此脚本添加执行权限<br>3. 执行此脚本</p>



<p>脚本分割线里的变量：<br>1. directory=download-eternalcenter #本地的缓冲目录<br>2. gituser=mingyuzhu #GitHub 用户<br>3. gitemail=mingyu.zhu@eternalcenter.com #GitHub 邮箱<br>4. gitrepository=download-eternalcenter #GitHub 库<br>5. gitbranch=’master’ #GitHub 库的分支<br>6. backupfile=all #备份后的文件<br>7. keyword=clone #同目录下要备份目录名称的关键字</p>



<p>注意：需要提前安装 git 和 git-lfs，注册 GitHub，创建相应的 GitHub 库，并且创建和设置了对应的 ssh 密钥</p>



<h2>脚本：</h2>



<pre class="wp-block-code"><code>#!/bin/bash

####################### Separator ########################

directory=download-eternalcenter
gituser=mingyuzhu
gitemail=mingyu.zhu@eternalcenter.com
gitrepository=download-eternalcenter
gitbranch='master'
backupfile=all
keyword=clone

####################### Separator ########################

backupdirectory=`ls -rtlh | grep $keyword | awk '{print $NF}' | tail -1`

sqlfile=`ls $backupdirectory | grep sql`
tarfile=`ls $backupdirectory | grep tar`

rm -rf $directory
mkdir -p $directory &amp;> /dev/null

echo $gituser
git config --global user.email "$gitemail"
git config --global user.name "$gituser"

rm -rf $directory
mkdir -p $directory &amp;> /dev/null
cd $directory
git init
git lfs install
git remote add origin git@github.com:$gituser/$gitrepository
git pull --rebase origin $gitbranch -f
git lfs track *
git filter-branch --force --index-filter 'git rm --cached --ignore-unmatch *' --prune-empty --tag-name-filter cat -- --all
git commit -m 'cleapup'
git push -u origin $gitbranch -f
rm -rf .git/refs/original/
git reflog expire --expire=now --all
git gc --prune=now
git gc --aggressive --prune=now

cd ..

rm -rf $directory
mkdir -p $directory &amp;> /dev/null
cd $directory
git init
git lfs install
git remote add origin git@github.com:$gituser/$gitrepository
git pull --rebase origin $gitbranch -f
git lfs track *
git rm *
git commit -m 'cleapup'

cd ../$backupdirectory/
tar -zcvf ../$directory/$backupfile.tar.gz *
cd ../$directory

git lfs track *
git add *
git status
git commit -m 'upload'
git push -u origin $gitbranch -f
cd ..</code></pre>
]]></content:encoded>
					
		
		
			</item>
		<item>
		<title>[工具] Shell 将同目录下最新的某个目录里的所有文件替换到 GitHub 库里</title>
		<link>https://eternalcenter-2022-02.github.io/shell-github-replace/</link>
		
		<dc:creator><![CDATA[Mingyu Zhu]]></dc:creator>
		<pubDate>Sat, 18 Dec 2021 13:11:35 +0000</pubDate>
				<category><![CDATA[Chinese (中文)]]></category>
		<category><![CDATA[Git]]></category>
		<category><![CDATA[Languages (语言)]]></category>
		<category><![CDATA[Other Services (其他服务)]]></category>
		<category><![CDATA[Services (服务)]]></category>
		<category><![CDATA[Shell]]></category>
		<category><![CDATA[Shell Backup (备份)]]></category>
		<category><![CDATA[Shell Tool (工具)]]></category>
		<guid isPermaLink="false">https://eternalcenter-2022-02.github.io/?p=19836</guid>

					<description><![CDATA[介绍： 作者：朱明宇名称：将同目录下最新的某个目录里的所有文件替换到 GitHub 库里作用：将同目录下最新的某个目录里的所有文件替换到 GitHub 库里 使用方法：1. 在此脚本的分割线内写入相应的内容2. 给此脚本添加执行权限3. 执行此脚本 脚本分割线里的变量：1. directory=download-eternalcenter #本地的缓冲目录2. gituser=mingyuzhu #GitHub 用户3. gitemail=mingyu.zhu@eternalcenter.com #GitHub 邮箱4. gitrepository=download-eternalcenter #GitHub 库5. gitbranch=’master’ #GitHub 库的分支6. backupfile=all #备份后的文件7. keyword=clone #同目录下要备份目录名称的关键字 注意：需要提前安装 git，注册 GitHub，创建相应的 GitHub 库，并且创建和设置了对应的 ssh 密钥 脚本：]]></description>
										<content:encoded><![CDATA[
<h2>介绍：</h2>



<p>作者：朱明宇<br>名称：将同目录下最新的某个目录里的所有文件替换到 GitHub 库里<br>作用：将同目录下最新的某个目录里的所有文件替换到 GitHub 库里</p>



<p>使用方法：<br>1. 在此脚本的分割线内写入相应的内容<br>2. 给此脚本添加执行权限<br>3. 执行此脚本</p>



<p>脚本分割线里的变量：<br>1. directory=download-eternalcenter #本地的缓冲目录<br>2. gituser=mingyuzhu #GitHub 用户<br>3. gitemail=mingyu.zhu@eternalcenter.com #GitHub 邮箱<br>4. gitrepository=download-eternalcenter #GitHub 库<br>5. gitbranch=’master’ #GitHub 库的分支<br>6. backupfile=all #备份后的文件<br>7. keyword=clone #同目录下要备份目录名称的关键字</p>



<p>注意：需要提前安装 git，注册 GitHub，创建相应的 GitHub 库，并且创建和设置了对应的 ssh 密钥</p>



<h2>脚本：</h2>



<pre class="wp-block-code"><code>#!/bin/bash

####################### Separator ########################

directory=download-eternalcenter
gituser=mingyuzhu
gitemail=mingyu.zhu@eternalcenter.com
gitrepository=download-eternalcenter
gitbranch='master'
backupfile=all
keyword=clone

####################### Separator ########################

backupdirectory=`ls -rtlh | grep $keyword | awk '{print $NF}' | tail -1`

sqlfile=`ls $backupdirectory | grep sql`
tarfile=`ls $backupdirectory | grep tar`

rm -rf $directory
mkdir -p $directory &amp;> /dev/null

echo $gituser
git config --global user.email "$gitemail"
git config --global user.name "$gituser"

rm -rf $directory
mkdir -p $directory &amp;> /dev/null
cd $directory
git init
git remote add origin git@github.com:$gituser/$gitrepository
git pull --rebase origin $gitbranch -f
git filter-branch --force --index-filter 'git rm --cached --ignore-unmatch *' --prune-empty --tag-name-filter cat -- --all
git commit -m 'cleapup'
git push -u origin $gitbranch -f
rm -rf .git/refs/original/
git reflog expire --expire=now --all
git gc --prune=now
git gc --aggressive --prune=now

cd ..

rm -rf $directory
mkdir -p $directory &amp;> /dev/null
cd $directory
git init
git remote add origin git@github.com:$gituser/$gitrepository
git pull --rebase origin $gitbranch -f
git rm *
git commit -m 'cleapup'

cd ../$backupdirectory/
tar -zcvf ../$directory/$backupfile.tar.gz *
cd ../$directory

git add *
git status
git commit -m 'upload'
git push -u origin $gitbranch -f
cd ..</code></pre>
]]></content:encoded>
					
		
		
			</item>
		<item>
		<title>[排错] Red Hat Satellite 客户端解决注册成功但是无法获取软件库</title>
		<link>https://eternalcenter-2022-02.github.io/debug-red-hat-satellite-repo-restore/</link>
		
		<dc:creator><![CDATA[Mingyu Zhu]]></dc:creator>
		<pubDate>Fri, 05 Nov 2021 12:36:40 +0000</pubDate>
				<category><![CDATA[Chinese (中文)]]></category>
		<category><![CDATA[Other Services (其他服务)]]></category>
		<category><![CDATA[Red Hat Satellite]]></category>
		<category><![CDATA[Services (服务)]]></category>
		<guid isPermaLink="false">https://eternalcenter-2022-02.github.io/?p=18179</guid>

					<description><![CDATA[报错代码： 解决方法： 步骤一：确保 /etc/pki/product/69.pem 文件的存在，且权限和下面的一致 步骤二：确保 /etc/pki/product-default/69.pem 文件的存在，且权限和下面的一致 步骤三：如果步骤一和步骤二中的文件不存在3.1 可以从其他正常的客户端那里拷贝 （步骤略） 3.2 可以从以下网址里下载 https://access.redhat.com/labs/rhpc/]]></description>
										<content:encoded><![CDATA[
<h2>报错代码：</h2>



<pre class="wp-block-code"><code># subscription-manager repos
This system has no repositories available through subscriptions.</code></pre>



<h2>解决方法：</h2>



<h4>步骤一：确保 /etc/pki/product/69.pem 文件的存在，且权限和下面的一致</h4>



<pre class="wp-block-code"><code># ls -l /etc/pki/product/69.pem
-rw-r----- 1 root root 2159 Nov  5 17:36 /etc/pki/product/69.pem</code></pre>



<h4>步骤二：确保 /etc/pki/product-default/69.pem 文件的存在，且权限和下面的一致</h4>



<pre class="wp-block-code"><code># ls -l /etc/pki/product-default/69.pem
-rw-r----- 1 644 root 2159 Nov  5 17:36 /etc/pki/product-default/69.pem</code></pre>



<h4>步骤三：如果步骤一和步骤二中的文件不存在<br>3.1 可以从其他正常的客户端那里拷贝</h4>



<p>（步骤略）</p>



<h4>3.2 可以从以下网址里下载</h4>



<p class="has-text-align-left"><a href="https://access.redhat.com/labs/rhpc/" target="_blank" rel="noreferrer noopener">https://access.redhat.com/labs/rhpc/</a></p>
]]></content:encoded>
					
		
		
			</item>
		<item>
		<title>[步骤] Red Hat Satellite 客户端 UUID 的显示</title>
		<link>https://eternalcenter-2022-02.github.io/red-hat-satellite-client-uuid/</link>
		
		<dc:creator><![CDATA[Mingyu Zhu]]></dc:creator>
		<pubDate>Fri, 05 Nov 2021 12:34:23 +0000</pubDate>
				<category><![CDATA[Chinese (中文)]]></category>
		<category><![CDATA[Other Services (其他服务)]]></category>
		<category><![CDATA[Red Hat Satellite]]></category>
		<category><![CDATA[Services (服务)]]></category>
		<guid isPermaLink="false">https://eternalcenter-2022-02.github.io/?p=18176</guid>

					<description><![CDATA[步骤一：规划拓扑1.1 服务器列表 Red Hat Satellite 服务端Red Hat Satellite 客户端 1.2 服务器列表简介 Red Hat Satellite 客户端注册到 Red Hat Satellite 服务端获取软件和补丁 步骤二：获取 Red Hat Satellite 客户端的 UUID （只在 Red Hat Satellite 客户端执行以下步骤） 步骤三：确认 Red Hat Satellite 客户端的 UUID 在服务端中出现 （只在 Red Hat Satellite 服务端执行以下步骤） 步骤四：显示 Red Hat Satellite 客户端在服务端中的具体信息 （只在 Red Hat Satellite 服务端执行以下步骤） （补充：在 vim 中查找对应客户端的 &#8230; <p class="link-more"><a href="https://eternalcenter-2022-02.github.io/red-hat-satellite-client-uuid/" class="more-link">Continue reading<span class="screen-reader-text"> "[步骤] Red Hat Satellite 客户端 UUID 的显示"</span></a></p>]]></description>
										<content:encoded><![CDATA[
<h4 id="步骤一-规划拓扑-1-1-服务器列表">步骤一：规划拓扑<br>1.1 服务器列表</h4>



<p>Red Hat Satellite 服务端<br>Red Hat Satellite 客户端</p>



<h4 id="1-2-服务器列表简介">1.2 服务器列表简介</h4>



<p>Red Hat Satellite 客户端注册到 Red Hat Satellite 服务端获取软件和补丁</p>



<h4 id="步骤二-获取-red-hat-satellite-客户端的-uuid">步骤二：获取 Red Hat Satellite 客户端的 UUID</h4>



<p>（只在 Red Hat Satellite 客户端执行以下步骤）</p>



<pre class="wp-block-code"><code># subscription-manager facts --list | grep -i UUID</code></pre>



<h4 id="步骤三-确认-red-hat-satellite-客户端的-uuid-在服务端中出现">步骤三：确认 Red Hat Satellite 客户端的 UUID 在服务端中出现</h4>



<p>（只在 Red Hat Satellite 服务端执行以下步骤）</p>



<pre class="wp-block-code"><code># cat /var/log/rhsm/rhsm.log | grep -i &lt;client's UUID&gt;</code></pre>



<h4 id="步骤四-显示-red-hat-satellite-客户端在服务端中的具体信息">步骤四：显示 Red Hat Satellite 客户端在服务端中的具体信息</h4>



<p>（只在 Red Hat Satellite 服务端执行以下步骤）</p>



<pre class="wp-block-code"><code># vim /var/log/rhsm/rhsm.log</code></pre>



<p>（补充：在 vim 中查找对应客户端的 UUID 并联系上下文进行显示）</p>
]]></content:encoded>
					
		
		
			</item>
		<item>
		<title>[步骤] Red Hat Satellite Virt-who 账号或密码的更换</title>
		<link>https://eternalcenter-2022-02.github.io/virt-who-change/</link>
		
		<dc:creator><![CDATA[Mingyu Zhu]]></dc:creator>
		<pubDate>Fri, 05 Nov 2021 12:23:24 +0000</pubDate>
				<category><![CDATA[Chinese (中文)]]></category>
		<category><![CDATA[Other Services (其他服务)]]></category>
		<category><![CDATA[Red Hat Satellite]]></category>
		<category><![CDATA[Services (服务)]]></category>
		<guid isPermaLink="false">https://eternalcenter-2022-02.github.io/?p=18168</guid>

					<description><![CDATA[内容一：Virt-who 账号的作用 1) Virt-who 的作用是让 Red Hat Satellite 服务器能判断虚拟机在哪一台物理机上运行2) Redhat 的无限量 license 必须要让虚拟机在 license 所在的物理机上运行才能获得软件和补丁3) Virt-who 必须正常无限连 license 才能生效4) 而 Virt-who 账号的作用就是有权限登陆对应的平台，让 Red Hat Satellite 服务器能判断虚拟机在哪一台物理机上运行 内容二：修改 Virt-who 账号或密码2.1 进入 Virt-who 的配置页面 登陆 Satellite 网页 &#8211;&#62; 基础架构 &#8211;&#62; Virt-who Configurations &#8211;&#62; 对应的 Name 的编辑 2.2 修改账号和密码 （步骤略） 内容三：重新部署 Virt-who3.1 进入 Virt-who 的 Deploy 页面 登陆 &#8230; <p class="link-more"><a href="https://eternalcenter-2022-02.github.io/virt-who-change/" class="more-link">Continue reading<span class="screen-reader-text"> "[步骤] Red Hat Satellite Virt-who 账号或密码的更换"</span></a></p>]]></description>
										<content:encoded><![CDATA[
<h4>内容一：Virt-who 账号的作用</h4>



<p>1) Virt-who 的作用是让 Red Hat Satellite 服务器能判断虚拟机在哪一台物理机上运行<br>2) Redhat 的无限量 license 必须要让虚拟机在 license 所在的物理机上运行才能获得软件和补丁<br>3) Virt-who 必须正常无限连 license 才能生效<br>4) 而 Virt-who 账号的作用就是有权限登陆对应的平台，让 Red Hat Satellite 服务器能判断虚拟机在哪一台物理机上运行</p>



<h4>内容二：修改 Virt-who 账号或密码<br>2.1 进入 Virt-who 的配置页面</h4>



<p>登陆 Satellite 网页  &#8211;&gt; 基础架构 &#8211;&gt; Virt-who Configurations &#8211;&gt; 对应的 Name 的编辑 </p>



<h4>2.2 修改账号和密码</h4>



<p>（步骤略）</p>



<h4>内容三：重新部署 Virt-who<br>3.1 进入 Virt-who 的 Deploy 页面 </h4>



<p>登陆 Satellite 网页 &#8211;&gt; 基础架构 &#8211;&gt; Virt-who Configurations &#8211;&gt; 对应的 Name &#8211;&gt; Deploy </p>



<h4>3.2 执行里面的步骤</h4>



<p>（步骤略）</p>
]]></content:encoded>
					
		
		
			</item>
		<item>
		<title>[排错] Linux 解决发送邮件时报错 “send-mail: fatal: parameter inet_interfaces: no local interface found for ::1”</title>
		<link>https://eternalcenter-2022-02.github.io/mail-debug/</link>
		
		<dc:creator><![CDATA[Mingyu Zhu]]></dc:creator>
		<pubDate>Fri, 27 Nov 2020 13:06:51 +0000</pubDate>
				<category><![CDATA[Chinese (中文)]]></category>
		<category><![CDATA[Mail]]></category>
		<category><![CDATA[Other Services (其他服务)]]></category>
		<category><![CDATA[Services (服务)]]></category>
		<guid isPermaLink="false">https://eternalcenter-2022-02.github.io/?p=11791</guid>

					<description><![CDATA[报错代码： 解决方法： 步骤一：修改 postfix 的配置文件 将以下内容： 修改为： 步骤二：重启 postfix 服务]]></description>
										<content:encoded><![CDATA[
<h2>报错代码：</h2>



<pre class="wp-block-code"><code>send-mail: fatal: parameter inet_interfaces: no local interface found for ::1</code></pre>



<h2>解决方法：</h2>



<h4>步骤一：修改 postfix 的配置文件</h4>



<pre class="wp-block-code"><code># vim /etc/postfix/main.cf</code></pre>



<p>将以下内容：</p>



<pre class="wp-block-code"><code>......
inet_interfaces = localhost
......
inet_protocols = all
......</code></pre>



<p>修改为：</p>



<pre class="wp-block-code"><code>......
inet_interfaces = all
......
inet_protocols = all
......</code></pre>



<h4>步骤二：重启 postfix 服务</h4>



<pre class="wp-block-code"><code># systemctl restart postfix</code></pre>
]]></content:encoded>
					
		
		
			</item>
		<item>
		<title>[实验] Linux 远程日志的集中管理和分文件存储 （通过 Rsyslog 实现）</title>
		<link>https://eternalcenter-2022-02.github.io/rsyslog-set/</link>
		
		<dc:creator><![CDATA[Mingyu Zhu]]></dc:creator>
		<pubDate>Mon, 12 Oct 2020 14:20:47 +0000</pubDate>
				<category><![CDATA[Chinese (中文)]]></category>
		<category><![CDATA[Other Services (其他服务)]]></category>
		<category><![CDATA[Rsyslog]]></category>
		<category><![CDATA[Services (服务)]]></category>
		<category><![CDATA[System (系统)]]></category>
		<category><![CDATA[System General Log (系统普通日志)]]></category>
		<category><![CDATA[System Log (系统日志)]]></category>
		<category><![CDATA[System Network & System Security & System Log (系统网络 & 系统安全 & 系统日志)]]></category>
		<guid isPermaLink="false">https://eternalcenter-2022-02.github.io/?p=11535</guid>

					<description><![CDATA[步骤目录： 步骤一：规划拓扑1.1 服务器列表1.2 服务器列表简介 步骤二：系统环境要求 步骤三：配置 rsyslog 服务端3.1 修改 rsyslog 配置文件的案例3.1.1 案例一3.1.2 案例二3.1.3 案例三3.1.4 案例四3.1.5 案例五3.2 重启 rsyslog 服务 步骤四：配置 rsyslog 客户端4.1 修改 rsyslog 客户端的案例4.2 重启 rsyslog 服务 步骤五：测试 rsyslog 服务5.1 在 rsyslog 客户端上发送日志5.2 在 rsyslog 服务端上显示日志 具体的操作步骤： 步骤一：规划拓扑1.1 服务器列表 rsyslog 服务端 IP 地址:192.168.0.11rsyslog 客户端 IP 地址:192.168.0.12 1.2 服务器列表简介 rsyslog 客户端将日志发送给 rsyslog 服务端，并实现分文件存储 步骤二：系统环境要求 1) &#8230; <p class="link-more"><a href="https://eternalcenter-2022-02.github.io/rsyslog-set/" class="more-link">Continue reading<span class="screen-reader-text"> "[实验] Linux 远程日志的集中管理和分文件存储 （通过 Rsyslog 实现）"</span></a></p>]]></description>
										<content:encoded><![CDATA[
<h2 id="步骤目录">步骤目录：</h2>



<h4 id="步骤一-规划拓扑1-1-服务器列表1-2-服务器列表简介">步骤一：规划拓扑<br>1.1 服务器列表<br>1.2 服务器列表简介</h4>



<h4 id="步骤二-系统环境要求">步骤二：系统环境要求</h4>



<h4 id="步骤三-配置-rsyslog-服务端3-1-修改-rsyslog-配置文件的案例3-1-1-案例一3-1-2-案例二3-1-3-案例三3-1-4-案例四3-1-5-案例五3-2-重启-rsyslog-服务">步骤三：配置 rsyslog 服务端<br>3.1 修改 rsyslog 配置文件的案例<br>3.1.1 案例一<br>3.1.2 案例二<br>3.1.3 案例三<br>3.1.4 案例四<br>3.1.5 案例五<br>3.2 重启 rsyslog 服务</h4>



<h4 id="步骤四-配置-rsyslog-客户端4-1-修改-rsyslog-客户端的案例4-2-重启-rsyslog-服务">步骤四：配置 rsyslog 客户端<br>4.1 修改 rsyslog 客户端的案例<br>4.2 重启 rsyslog 服务</h4>



<h4 id="步骤五-测试-rsyslog-服务5-1-在-rsyslog-客户端上发送日志5-2-在-rsyslog-服务端上显示日志">步骤五：测试 rsyslog 服务<br>5.1 在 rsyslog 客户端上发送日志<br>5.2 在 rsyslog 服务端上显示日志</h4>



<h2 id="具体的操作步骤">具体的操作步骤：</h2>



<h4 id="步骤一-规划拓扑1-1-服务器列表">步骤一：规划拓扑<br>1.1 服务器列表</h4>



<p>rsyslog 服务端 IP 地址:192.168.0.11<br>rsyslog 客户端 IP 地址:192.168.0.12</p>



<h4 id="1-2-服务器列表简介">1.2 服务器列表简介</h4>



<p>rsyslog 客户端将日志发送给 rsyslog 服务端，并实现分文件存储</p>



<h4 id="步骤二-系统环境要求">步骤二：系统环境要求</h4>



<p>1) 所有服务器的系统都需要是 CentOS 8 版本<br>2) 所有服务器都要关闭防火墙<br>3) 所有服务器都要关闭 SELinux<br>4) 需要按照拓扑图给对应的服务器配置好 IP 地址和主机名<br>5) 所有服务器都要可以相互 ping 通自己和对方的 IP 地址和主机名</p>



<h4 id="步骤三-配置-rsyslog-服务端3-1-修改-rsyslog-配置文件的案例3-1-1-案例一">步骤三：配置 rsyslog 服务端<br>3.1 修改 rsyslog 配置文件的案例<br>3.1.1 案例一</h4>



<p>（只在 rsyslog 服务端执行以下步骤）</p>



<pre class="wp-block-code"><code># vim /etc/rsyslog.conf</code></pre>



<p>添加以下内容：</p>



<pre class="wp-block-code"><code>......
module(load="imudp")
input(type="imudp" port="514")
module(load="imtcp")
input(type="imtcp" port="514")</code></pre>



<p>（<br>补充：<br>1) 使用 UDP 的 514 端口接收日志<br>2) 使用 TCP 的 514 端口接收日志<br>3) 此配置会将所有 rsyslog 客户端的日志存储在 rsyslog 服务端的 /var/log/message 里<br>）</p>



<h4 id="3-1-2-案例二">3.1.2 案例二</h4>



<p>（只在 rsyslog 服务端执行以下步骤）</p>



<pre class="wp-block-code"><code># vim /etc/rsyslog.conf</code></pre>



<p>添加以下内容：</p>



<pre class="wp-block-code"><code>......
module(load="imudp")
input(type="imudp" port="514")
module(load="imtcp")
input(type="imtcp" port="514")

$template DynFile,"/var/log/%HOSTNAME%.log"
*.* -?DynFile
&amp; ~</code></pre>



<p>（<br>补充：<br>1) 使用 UDP 的 514 端口接收日志<br>2) 使用 TCP 的 514 端口接收日志<br>3) 此配置会将每个 rsyslog 客户端的日志单独存储在 /var/log/ 下的一个文件里，此文件会以其所属系统名命名<br>）</p>



<h4 id="3-1-3-案例三">3.1.3 案例三</h4>



<p>（只在 rsyslog 服务端执行以下步骤）</p>



<pre class="wp-block-code"><code># vim /etc/rsyslog.conf</code></pre>



<p>添加以下内容：</p>



<pre class="wp-block-code"><code>......
module(load="imudp")
input(type="imudp" port="514")
module(load="imtcp")
input(type="imtcp" port="514")

$template DynFile,"/var/log/remotelog/%HOSTNAME%-%$YEAR%-%$MONTH%-%$DAY%-messages.log"
*.* -?DynFile
&amp; ~</code></pre>



<p>（<br>补充：<br>1) 使用 UDP 的 514 端口接收日志<br>2) 使用 TCP 的 514 端口接收日志<br>3) 此配置会将每个 rsyslog 客户端的日志单独存储在 /var/log/remotelog 下的一个文件里，此文件会以其创建时间和其所属系统名命名<br>）</p>



<h4 id="3-1-4-案例四">3.1.4 案例四</h4>



<p>（只在 rsyslog 服务端执行以下步骤）</p>



<pre class="wp-block-code"><code># vim /etc/rsyslog.conf</code></pre>



<p>添加以下内容：</p>



<pre class="wp-block-code"><code>......
module(load="imudp")
input(type="imudp" port="514")
module(load="imtcp")
input(type="imtcp" port="514")

$template DynFile,"/var/log/remotelog/%HOSTNAME%-%$YEAR%-%$MONTH%-%$DAY%-messages.log"
:fromhost-ip,!isequal,"127.0.0.1" -?DynFile
&amp; ~</code></pre>



<p>（<br>补充：<br>1) 使用 UDP 的 514 端口接收日志<br>2) 使用 TCP 的 514 端口接收日志<br>3) 此配置会将每个 rsyslog 客户端的日志单独存储在 /var/log/ 下的一个文件里，此文件会以其创建时间和其所属系统名命名<br>4) 此配置不会单独存储 rsyslog 服务端的日志<br>）</p>



<h4 id="3-1-5-案例五">3.1.5 案例五</h4>



<p>（只在 rsyslog 服务端执行以下步骤）</p>



<pre class="wp-block-code"><code># vim /etc/rsyslog.conf</code></pre>



<p>添加以下内容：</p>



<pre class="wp-block-code"><code>......
module(load="imudp")
input(type="imudp" port="514")
module(load="imtcp")
input(type="imtcp" port="514")

$template DynFile,"/var/log/syslog/system-%HOSTNAME%/messages.log"
*.* -?DynFile
&amp; ~</code></pre>



<p>（<br>补充：<br>1) 使用 UDP 的 514 端口接收日志<br>2) 使用 TCP 的 514 端口接收日志<br>3) 此配置会将每个 rsyslog 客户端的日志单独存储在 /var/log/ 下某个目录的 messages 文件里，此目录会以其所属系统名命名<br>）</p>



<h4 id="3-2-重启-rsyslog-服务">3.2 重启 rsyslog 服务</h4>



<p>（只在 rsyslog 服务端执行以下步骤）</p>



<pre class="wp-block-code"><code># systemctl restart rsyslog</code></pre>



<p>（<br>补充：<br>1) 使用 UDP 的 514 端口接收日志<br>2) 使用 TCP 的 514 端口接收日志<br>3) 需要在 3.1 修改 rsyslog 配置文件的案例中任选其一完成后在执行此步骤<br>）</p>



<h4 id="步骤四-配置-rsyslog-客户端4-1-修改-rsyslog-客户端的案例">步骤四：配置 rsyslog 客户端<br>4.1 修改 rsyslog 客户端的案例</h4>



<p>（只在 rsyslog 客户端执行以下步骤）</p>



<pre class="wp-block-code"><code># vim /etc/rsyslog.conf</code></pre>



<p>添加以下内容：</p>



<pre class="wp-block-code"><code>......
*.emerg;*.alert;*.crit;*.err;*.warning;*.notice;*.info  @192.168.0.11</code></pre>



<p>或者：</p>



<pre class="wp-block-code"><code>......
*.emerg;*.alert;*.crit;*.err;*.warning;*.notice;*.info  @@192.168.0.11</code></pre>



<p>（<br>补充：<br>1) 这里的 192.168.0.11 是指 rsyslog 服务端的 IP 地址<br>2) IP 地址前一个 “@” 符后是指使用 UDP 端口 514 传输日志<br>3) IP 地址前两个 “@” 符后是指使用 TCP 端口 514 传输日志<br>）</p>



<h4 id="4-2-重启-rsyslog-服务">4.2 重启 rsyslog 服务</h4>



<p>（只在 rsyslog 客户端执行以下步骤）</p>



<pre class="wp-block-code"><code># systemctl restart rsyslog</code></pre>



<h4 id="步骤五-测试-rsyslog-服务5-1-在-rsyslog-客户端上发送日志">步骤五：测试 rsyslog 服务<br>5.1 在 rsyslog 客户端上发送日志</h4>



<p>（只在 rsyslog 客户端执行以下步骤）</p>



<pre class="wp-block-code"><code># logger "This is our test log"</code></pre>



<p>（补充：这里以发送 This is our test log 信息为例）</p>



<h4 id="5-2-在-rsyslog-服务端上显示日志">5.2 在 rsyslog 服务端上显示日志</h4>



<p>（只在 rsyslog 服务端执行以下步骤）</p>



<pre class="wp-block-code"><code># cat /var/log/* | grep test</code></pre>
]]></content:encoded>
					
		
		
			</item>
		<item>
		<title>[步骤] 远程虚拟化平台的搭建</title>
		<link>https://eternalcenter-2022-02.github.io/remote-virtual-platform/</link>
		
		<dc:creator><![CDATA[Mingyu Zhu]]></dc:creator>
		<pubDate>Sat, 26 Sep 2020 10:10:37 +0000</pubDate>
				<category><![CDATA[Chinese (中文)]]></category>
		<category><![CDATA[Cloud Computing (云计算)]]></category>
		<category><![CDATA[KVM]]></category>
		<category><![CDATA[Other Services (其他服务)]]></category>
		<category><![CDATA[Services (服务)]]></category>
		<category><![CDATA[System (系统)]]></category>
		<category><![CDATA[System Computer (系统电脑)]]></category>
		<category><![CDATA[System Computer & System Hardware & System Installation & System Upgradation (系统电脑 & 系统硬件 & 系统安装 & 系统升级)]]></category>
		<category><![CDATA[Virtualization (虚拟化)]]></category>
		<category><![CDATA[VNC]]></category>
		<guid isPermaLink="false">https://eternalcenter-2022-02.github.io/?p=10587</guid>

					<description><![CDATA[步骤目录： 步骤一：规划拓扑1.1 电脑列表1.2 服务器列表简介 步骤二：给电脑安装 CentOS 8.2 系统 步骤三：安装图形系统桌面 步骤四：安装中文输入法4.1 安装中文库4.2 确认中文库已经安装4.3 安装中文输入法 步骤五：创建用户5.1 创建用户5.2 给用户设置密码 步骤六：增加 CentOS 8.2 系统的稳定性6.1 延长看门狗喂狗间隔以减少系统被软锁出现 softlockup 的几率6.1.1 临时延长看门狗喂狗间隔的时间6.1.2 永久延长看门狗喂狗间隔的时间6.1.2.1 添加延长看门狗喂狗间隔的设置6.1.2.2 让添加延长看门狗喂狗间隔的设置生效6.1.3 让 softlockup 触发后直接宕机6.2 禁止图形系统桌面的 DNS 和路由以避免系统崩溃6.2.1 添加禁止图形系统桌面的 DNS 和路由的设置6.2.2 让禁止图形系统桌面的 DNS 和路由的设置生效6.3 禁止图形系统界面自动黑屏或自动挂起6.4 让 SSH 联接永久不超时6.4.1 让 SSH 服务端的连接不超时6.4.2 让用户登陆永不超时6.4.2.1 在系统文件里添加让用户登陆永不超时的设置6.4.2.2 让用户登陆永不超时的设置立刻生效6.5 删除不需要的软件包以避免 CPU 占用过高而崩溃（选做） 步骤七：搭建虚拟化平台 步骤八：实现文件共享8.1 安装 &#8230; <p class="link-more"><a href="https://eternalcenter-2022-02.github.io/remote-virtual-platform/" class="more-link">Continue reading<span class="screen-reader-text"> "[步骤] 远程虚拟化平台的搭建"</span></a></p>]]></description>
										<content:encoded><![CDATA[
<h2 id="步骤目录">步骤目录：</h2>



<h4 id="步骤一-规划拓扑1-1-电脑列表1-2-服务器列表简介">步骤一：规划拓扑<br>1.1 电脑列表<br>1.2 服务器列表简介</h4>



<h4 id="步骤二-给电脑安装-centos-8-2-系统">步骤二：给电脑安装 CentOS 8.2 系统</h4>



<h4 id="步骤三-安装图形系统桌面">步骤三：安装图形系统桌面</h4>



<h4 id="步骤四-安装中文输入法4-1-安装中文库4-2-确认中文库已经安装4-3-安装中文输入法">步骤四：安装中文输入法<br>4.1 安装中文库<br>4.2 确认中文库已经安装<br>4.3 安装中文输入法</h4>



<h4 id="步骤五-创建用户5-1-创建用户5-2-给用户设置密码">步骤五：创建用户<br>5.1 创建用户<br>5.2 给用户设置密码</h4>



<h4 id="步骤六-增加-centos-8-2-系统的稳定性6-1-延长看门狗喂狗间隔以减少系统被软锁出现-softlockup-的几率6-1-1-临时延长看门狗喂狗间隔的时间6-1-2-永久延长看门狗喂狗间隔的时间6-1-2-1-添加延长看门狗喂狗间隔的设置6-1-2-2-让添加延长看门狗喂狗间隔的设置生效6-1-3-让-softlockup-触发后直接宕机6-2-禁止图形系统桌面的-dns-和路由以避免系统崩溃6-2-1-添加禁止图形系统桌面的-dns-和路由的设置6-2-2-让禁止图形系统桌面的-dns-和路由的设置生效6-3-禁止图形系统界面自动黑屏或自动挂起6-4-让-ssh-联接永久不超时6-4-1-让-ssh-服务端的连接不超时6-4-2-让用户登陆永不超时6-4-2-1-在系统文件里添加让用户登陆永不超时的设置6-4-2-2-让用户登陆永不超时的设置立刻生效6-5-删除不需要的软件包以避免-cpu-占用过高而崩溃-选做">步骤六：增加 CentOS 8.2 系统的稳定性<br>6.1 延长看门狗喂狗间隔以减少系统被软锁出现 softlockup 的几率<br>6.1.1 临时延长看门狗喂狗间隔的时间<br>6.1.2 永久延长看门狗喂狗间隔的时间<br>6.1.2.1 添加延长看门狗喂狗间隔的设置<br>6.1.2.2 让添加延长看门狗喂狗间隔的设置生效<br>6.1.3 让 softlockup 触发后直接宕机<br>6.2 禁止图形系统桌面的 DNS 和路由以避免系统崩溃<br>6.2.1 添加禁止图形系统桌面的 DNS 和路由的设置<br>6.2.2 让禁止图形系统桌面的 DNS 和路由的设置生效<br>6.3 禁止图形系统界面自动黑屏或自动挂起<br>6.4 让 SSH 联接永久不超时<br>6.4.1 让 SSH 服务端的连接不超时<br>6.4.2 让用户登陆永不超时<br>6.4.2.1 在系统文件里添加让用户登陆永不超时的设置<br>6.4.2.2 让用户登陆永不超时的设置立刻生效<br>6.5 删除不需要的软件包以避免 CPU 占用过高而崩溃（选做）</h4>



<h4 id="步骤七-搭建虚拟化平台">步骤七：搭建虚拟化平台</h4>



<h4 id="步骤八-实现文件共享8-1-安装-samba-服务8-2-配置-samba-服务的配置文件8-3-设置-samba-服务共享用户8-3-1-给-samba-服务共享用户设置-samba-共享密码8-3-2-显示-samba-服务共享用户是否可用8-4-生成-samba-服务共享目录8-4-1-生成-samba-服务共享目录8-4-2-给-samba-服务共享目录设置权限8-4-3-给-samba-服务共享目录设置所属主和所属组8-4-4-给-samba-服务共享目录设置-selinux-标签8-4-5-让-samba-服务共享目录上的-selinux-标签立刻生效8-5-启动-samba-服务并设置为开机自动启动8-6-在系统防火墙开放-samba-的端口8-6-1-在系统防火墙开放-samba-的端口8-6-2-让系统防火墙重新加载">步骤八：实现文件共享<br>8.1 安装 Samba 服务<br>8.2 配置 Samba 服务的配置文件<br>8.3 设置 Samba 服务共享用户<br>8.3.1 给 Samba 服务共享用户设置 Samba 共享密码<br>8.3.2 显示 Samba 服务共享用户是否可用<br>8.4 生成 Samba 服务共享目录<br>8.4.1 生成 Samba 服务共享目录<br>8.4.2 给 Samba 服务共享目录设置权限<br>8.4.3 给 Samba 服务共享目录设置所属主和所属组<br>8.4.4 给 Samba 服务共享目录设置 selinux 标签<br>8.4.5 让 Samba 服务共享目录上的 selinux 标签立刻生效<br>8.5 启动 Samba 服务并设置为开机自动启动<br>8.6 在系统防火墙开放 Samba 的端口<br>8.6.1 在系统防火墙开放 Samba 的端口<br>8.6.2 让系统防火墙重新加载</h4>



<h4 id="步骤九-实现远程桌面9-1-安装-vnc-服务9-2-设置-vnc-服务共享用户9-2-1-进入用户9-2-2-给-vnc-服务共享用户设置-vnc-远程密码9-2-3-退出用户9-3-启动-vnc-并设置为开机自动启动9-3-1-创建开启-vnc-的脚本-vnc-sh9-3-1-1-进入到用户9-3-1-2-创建开启-vnc-的脚本-vnc-sh9-3-1-3-退出用户9-3-2-执行开启-vnc-的脚本9-3-2-1-开机执行开启-vnc-的脚本9-3-2-1-1-配置开机执行的文件9-3-2-1-2-给开机执行的文件执行权限9-3-2-2-定期执行开启-vnc-的脚本9-3-2-2-1-进入到用户9-3-2-2-2-配置定期执行的文件9-3-2-2-3-退出用户">步骤九：实现远程桌面<br>9.1 安装 vnc 服务<br>9.2 设置 VNC 服务共享用户<br>9.2.1 进入用户<br>9.2.2 给 VNC 服务共享用户设置 VNC 远程密码<br>9.2.3 退出用户<br>9.3 启动 VNC 并设置为开机自动启动<br>9.3.1 创建开启 VNC 的脚本 ~/vnc.sh<br>9.3.1.1 进入到用户<br>9.3.1.2 创建开启 VNC 的脚本 ~/vnc.sh<br>9.3.1.3 退出用户<br>9.3.2 执行开启 VNC 的脚本<br>9.3.2.1 开机执行开启 VNC 的脚本<br>9.3.2.1.1 配置开机执行的文件<br>9.3.2.1.2 给开机执行的文件执行权限<br>9.3.2.2 定期执行开启 VNC 的脚本<br>9.3.2.2.1 进入到用户<br>9.3.2.2.2 配置定期执行的文件<br>9.3.2.2.3 退出用户</h4>



<h4 id="步骤十-设置-ssh-内网穿透10-1-生成-ssh-密钥10-1-1-进入到用户10-1-2-生成-ssh-密钥10-1-3-退出用户10-2-实现无密钥-ssh10-2-1-进入到用户10-2-2-让电脑可以无密钥-ssh-vps10-2-3-让-vps-可以无密钥-ssh-自己10-2-4-让客户端可以远程-vps-和电脑10-2-5-退出用户10-3-建立电脑到-vps-的-ssh-隧道并设置为开机自启10-3-1-创建建立电脑到-vps-的-ssh-隧道的脚本-ssh-sh10-3-1-1-进入到用户10-3-1-2-创建建立电脑到-vps-的-ssh-隧道的脚本-ssh-sh10-3-1-3-退出用户10-3-2-执行电脑到-vps-的-ssh-隧道的脚本10-3-2-1-开机执行开启电脑到-vps-的-ssh-隧道的脚本10-3-2-1-1-配置开机执行的文件10-3-2-1-2-给开机执行的文件执行权限10-3-3-定期执行电脑到-vps-的-ssh-隧道的脚本10-3-3-1-进入到用户10-3-3-2-配置定期执行的文件10-3-3-3-退出用户10-4-建立-vps-的-ssh-隧道端口映射并设置为开机自启10-4-1-创建建立-vps-的-ssh-隧道端口映射的脚本10-4-1-1-进入到用户10-4-1-2-创建建立-vps-的-ssh-隧道端口映射的脚本10-4-1-3-退出用户10-4-2-执行电脑到-vps-的-ssh-隧道的脚本10-4-2-1-开机执行开启电脑到-vps-的-ssh-隧道的脚本10-4-2-1-1-配置开机执行的文件10-4-2-1-2-给开机执行的文件执行权限10-4-3-定期执行电脑到-vps-的-ssh-隧道的脚本10-4-3-1-进入到用户10-4-3-2-配置定期执行的文件10-4-4-退出用户10-4-5-打开外网-vps-对应端口的防火墙10-4-5-1-打开外网-vps-对应端口的防火墙10-4-5-2-让刚刚外网-vps-刚刚配置的防火墙生效">步骤十：设置 SSH 内网穿透<br>10.1 生成 SSH 密钥<br>10.1.1 进入到用户<br>10.1.2 生成 SSH 密钥<br>10.1.3 退出用户<br>10.2 实现无密钥 SSH<br>10.2.1 进入到用户<br>10.2.2 让电脑可以无密钥 SSH VPS<br>10.2.3 让 VPS 可以无密钥 SSH 自己<br>10.2.4 让客户端可以远程 VPS 和电脑<br>10.2.5 退出用户<br>10.3 建立电脑到 VPS 的 SSH 隧道并设置为开机自启<br>10.3.1 创建建立电脑到 VPS 的 SSH 隧道的脚本 ～/ssh.sh<br>10.3.1.1 进入到用户<br>10.3.1.2 创建建立电脑到 VPS 的 SSH 隧道的脚本 ～/ssh.sh<br>10.3.1.3 退出用户<br>10.3.2 执行电脑到 VPS 的 SSH 隧道的脚本<br>10.3.2.1 开机执行开启电脑到 VPS 的 SSH 隧道的脚本<br>10.3.2.1.1 配置开机执行的文件<br>10.3.2.1.2 给开机执行的文件执行权限<br>10.3.3 定期执行电脑到 VPS 的 SSH 隧道的脚本<br>10.3.3.1 进入到用户<br>10.3.3.2 配置定期执行的文件<br>10.3.3.3 退出用户<br>10.4 建立 VPS 的 SSH 隧道端口映射并设置为开机自启<br>10.4.1 创建建立 VPS 的 SSH 隧道端口映射的脚本<br>10.4.1.1 进入到用户<br>10.4.1.2 创建建立 VPS 的 SSH 隧道端口映射的脚本<br>10.4.1.3 退出用户<br>10.4.2 执行电脑到 VPS 的 SSH 隧道的脚本<br>10.4.2.1 开机执行开启电脑到 VPS 的 SSH 隧道的脚本<br>10.4.2.1.1 配置开机执行的文件<br>10.4.2.1.2 给开机执行的文件执行权限<br>10.4.3 定期执行电脑到 VPS 的 SSH 隧道的脚本<br>10.4.3.1 进入到用户<br>10.4.3.2 配置定期执行的文件<br>10.4.4 退出用户<br>10.4.5 打开外网 VPS 对应端口的防火墙<br>10.4.5.1 打开外网 VPS 对应端口的防火墙<br>10.4.5.2 让刚刚外网 VPS 刚刚配置的防火墙生效</h4>



<h4 id="步骤十一-加强-ssh-的安全性-选做-11-1-禁止-root-被-ssh-选做-11-2-禁止使用密码被-ssh-选做">步骤十一：加强 SSH 的安全性（选做）<br>11.1 禁止 root 被 SSH（选做）<br>11.2 禁止使用密码被 SSH（选做）</h4>



<h4 id="步骤十二-私有远程桌面和虚拟化平台的使用12-1-客户端-ssh-联接电脑的方法12-1-1-客户端和电脑不在同一内网时12-1-2-客户端和电脑在同一内网时12-2-客户端使用电脑虚拟化平台的的方法12-2-1-客户端和电脑不在同一内网时12-2-1-1-在客户端上联接电脑12-2-1-2-通过-ssh-开启虚拟化图形管理平台12-2-2-客户端和电脑在同一内网时12-2-2-1-在客户端上联接电脑12-2-2-2-通过-ssh-开启虚拟化图形管理平台12-3-客户端使用私有远程桌面的方法12-3-1-客户端和电脑不在同一内网时12-3-2-客户端和电脑在同一内网时12-4-客户端在内网和电脑互传数据的方法12-4-1-在-windows-图形客户端上和电脑互传数据的方法12-4-2-在-linux-图形客户端上和电脑互传数据的方法">步骤十二：私有远程桌面和虚拟化平台的使用<br>12.1 客户端 SSH 联接电脑的方法<br>12.1.1 客户端和电脑不在同一内网时<br>12.1.2 客户端和电脑在同一内网时<br>12.2 客户端使用电脑虚拟化平台的的方法<br>12.2.1 客户端和电脑不在同一内网时<br>12.2.1.1 在客户端上联接电脑<br>12.2.1.2 通过 ssh 开启虚拟化图形管理平台<br>12.2.2 客户端和电脑在同一内网时<br>12.2.2.1 在客户端上联接电脑<br>12.2.2.2 通过 ssh 开启虚拟化图形管理平台<br>12.3 客户端使用私有远程桌面的方法<br>12.3.1 客户端和电脑不在同一内网时<br>12.3.2 客户端和电脑在同一内网时<br>12.4 客户端在内网和电脑互传数据的方法<br>12.4.1 在 Windows 图形客户端上和电脑互传数据的方法<br>12.4.2 在 Linux 图形客户端上和电脑互传数据的方法</h4>



<h4 id="步骤十三-客户端直接使用公网-ip-地址联接电脑13-1-实现此步骤所需环境13-2-在路由器上将电脑上的-22-端口映射到路由器上的公网-ip-地址上-这样路由器上的公网-ip-地址就变成电脑的公网-ip-地址了13-3-将电脑的公网-ip-地址放到-vps-上13-3-1-将电脑的公网-ip-地址放到-vps-上的意义13-3-2-创建将电脑的公网-ip-地址放到-vps-上的脚本13-3-2-1-进入到用户用户13-3-2-2-创建将电脑的公网-ip-地址放到-vps-上的脚本13-3-2-3-退出用户用户13-3-3-执行将电脑的公网-ip-地址放到-vps-上的脚本13-3-3-1-进入到用户用户13-3-3-2-配置定期执行的文件13-3-3-3-退出用户用户13-4-通过-ddns-服务显示电脑的公网-ip13-4-1-通过-ddns-服务显示电脑的公网-ip13-4-2-有些-ddns-服务可以在网关路由器上设置-并且通过手机-app-显示现在的公网-ip-地址">步骤十三：客户端直接使用公网 IP 地址联接电脑<br>13.1 实现此步骤所需环境<br>13.2 在路由器上将电脑上的 22 端口映射到路由器上的公网 IP 地址上，这样路由器上的公网 IP 地址就变成电脑的公网 IP 地址了<br>13.3 将电脑的公网 IP 地址放到 VPS 上<br>13.3.1 将电脑的公网 IP 地址放到 VPS 上的意义<br>13.3.2 创建将电脑的公网 IP 地址放到 VPS 上的脚本<br>13.3.2.1 进入到用户用户<br>13.3.2.2 创建将电脑的公网 IP 地址放到 VPS 上的脚本<br>13.3.2.3 退出用户用户<br>13.3.3 执行将电脑的公网 IP 地址放到 VPS 上的脚本<br>13.3.3.1 进入到用户用户<br>13.3.3.2 配置定期执行的文件<br>13.3.3.3 退出用户用户<br>13.4 通过 DDNS 服务显示电脑的公网 IP<br>13.4.1 通过 DDNS 服务显示电脑的公网 IP<br>13.4.2 有些 DDNS 服务可以在网关路由器上设置，并且通过手机 APP 显示现在的公网 IP 地址</h4>



<h2 id="具体的操作步骤">具体的操作步骤：</h2>



<h4 id="步骤一-规划拓扑1-1-电脑列表">步骤一：规划拓扑<br>1.1 电脑列表</h4>



<p>1) 一台可以联接公网的电脑<br>2) 一个 CentOS 8.2 系统的安装 U 盘<br>3) 一台可以联接公网并且有公网 IP 地址的 VPS<br>4) 一个可以联接公网并使用 SSH 和 VNC 的客户端</p>



<h4 id="1-2-服务器列表简介">1.2 服务器列表简介</h4>



<p>1) 电脑通过 SSH 建立联接到 VPS 的隧道，此操作会占用 VPS 的一个端口<br>2) VPS 通过 SSH 将联接电脑的隧道端口映射到一个新的端口<br>3) 客户端通过 SSH 联接到 VPS 映射出来的新端口，通过 SSH 或远程桌面使用虚拟化平台<br>4) 客户端和电脑如果在同一内网里则可以通过 Samba 互传数据</p>



<h4 id="步骤二-centos-8-2-系统的安装-u-盘给电脑安装系统">步骤二：CentOS 8.2 系统的安装 U 盘给电脑安装系统</h4>



<p>（只在电脑上执行以下步骤）<br>（步骤略）</p>



<p>（<br>补充：<br>安装系统时可选择以下选项：<br>1) 系统起动方式：BIOS<br>2) Keyboard：English(US)<br>3) Language Support：English(United States)<br>4) Time &amp; Date：Asia/ShangHai<br>5) Installation Source：Local media<br>6) Software Selection：Minial Install<br>7) Installation Destination：将主硬盘里的所有空间都分配给根分区<br>8) KDUMP：Kdump is disabled<br>9) Network &amp; Host Name：开启网络联接并设置好固定 DNS<br>10) SECURITY POLICY：No controller found<br>）</p>



<p>（这里以将 IP 地址设置为固定 IP 地址 192.168.0.1，DNS 设置为固定 DNS 8.8.8.8 为例）</p>



<h4 id="步骤三-安装图形系统桌面">步骤三：安装图形系统桌面</h4>



<p>（只在电脑上执行以下步骤）</p>



<pre class="wp-block-code"><code># yum groupinstall -y "Server with GUI"</code></pre>



<h4 id="步骤四-安装中文输入法4-1-安装中文库">步骤四：安装中文输入法<br>4.1 安装中文库</h4>



<p>（只在电脑上执行以下步骤）</p>



<pre class="wp-block-code"><code># yum -y install langpacks-zh_CN</code></pre>



<h4 id="4-2-确认中文库已经安装">4.2 确认中文库已经安装</h4>



<p>（只在电脑上执行以下步骤）</p>



<pre class="wp-block-code"><code># locale -a</code></pre>



<h4 id="4-3-安装中文输入法">4.3 安装中文输入法</h4>



<p>（只在电脑上执行以下步骤）</p>



<pre class="wp-block-code"><code># yum -y install ibus ibus-libpinyin</code></pre>



<h4 id="步骤五-创建用户用户5-1-创建用户用户">步骤五：创建用户用户<br>5.1 创建用户用户</h4>



<p>（分别在电脑、VPS 和客户端上执行以下步骤）</p>



<pre class="wp-block-code"><code># useradd zhumingyu</code></pre>



<p>（补充：这里创建用户 zhumingyu 为例）</p>



<h4 id="5-2-给用户用户设置密码">5.2 给用户用户设置密码</h4>



<p>（分别在电脑、VPS 和客户端上执行以下步骤）</p>



<pre class="wp-block-code"><code># passwd zhumingyu</code></pre>



<p>（补充：这里创建用户 zhumingyu 为例）</p>



<h4 id="步骤六-增加-centos-系统的稳定性6-1-延长看门狗喂狗间隔以减少系统被软锁出现-softlockup-的几率6-1-1-临时延长看门狗喂狗间隔的时间">步骤六：增加 CentOS 系统的稳定性<br>6.1 延长看门狗喂狗间隔以减少系统被软锁出现 softlockup 的几率<br>6.1.1 临时延长看门狗喂狗间隔的时间</h4>



<p>（分别在电脑和 VPS 上执行以下步骤）</p>



<pre class="wp-block-code"><code># sysctl -w kernel.watchdog_thresh=60</code></pre>



<h4 id="6-1-2-永久延长看门狗喂狗间隔的时间6-1-2-1-添加延长看门狗喂狗间隔的设置">6.1.2 永久延长看门狗喂狗间隔的时间<br>6.1.2.1 添加延长看门狗喂狗间隔的设置</h4>



<p>（只在电脑上执行以下步骤）</p>



<pre class="wp-block-code"><code># vim /etc/sysctl.conf</code></pre>



<p>添加以下内容：</p>



<pre class="wp-block-code"><code>......
kernel.watchdog_thresh=60</code></pre>



<h4 id="6-1-2-2-让添加延长看门狗喂狗间隔的设置生效">6.1.2.2 让添加延长看门狗喂狗间隔的设置生效</h4>



<p>（只在电脑上执行以下步骤）</p>



<pre class="wp-block-code"><code># sysctl -p</code></pre>



<h4 id="6-1-3-让-softlockup-触发后直接宕机">6.1.3 让 softlockup 触发后直接宕机</h4>



<p>（只在电脑上执行以下步骤）</p>



<pre class="wp-block-code"><code># echo 1 &gt; /proc/sys/kernel/softlockup_panic</code></pre>



<h4 id="6-2-禁止图形系统桌面的-dns-和路由以避免系统崩溃6-2-1-添加禁止图形系统桌面的-dns-和路由的设置">6.2 禁止图形系统桌面的 DNS 和路由以避免系统崩溃<br>6.2.1 添加禁止图形系统桌面的 DNS 和路由的设置</h4>



<p>（分别在电脑和 VPS 上执行以下步骤）</p>



<pre class="wp-block-code"><code># vim /etc/sysconfig/network-scripts/ifcfg-enp9s0</code></pre>



<p>添加以下内容：</p>



<pre class="wp-block-code"><code>......
PEERDNS=no
PEERROUTES=no</code></pre>



<p>（补充：这里的 ifcfg-enp9s0 是指网卡对应的配置文件，不同的网卡对应的配置文件不同，这里以网卡名 ifcfg-enp9s0 为例，需要给所有网卡添加此参数，这一步也可以在系统图形系统桌面上设置）</p>



<h4 id="6-2-2-让禁止图形系统桌面的-dns-和路由的设置生效">6.2.2 让禁止图形系统桌面的 DNS 和路由的设置生效</h4>



<p>（分别在电脑和 VPS 上执行以下步骤）</p>



<pre class="wp-block-code"><code># systemctl restart NetworkManager</code></pre>



<h4 id="6-3-禁止图形系统界面自动黑屏或自动挂起">6.3 禁止图形系统界面自动黑屏或自动挂起</h4>



<p>（只在电脑上执行以下步骤）</p>



<h4 id="6-4-让-ssh-联接永久不超时6-4-1-让-ssh-服务端的连接不超时">6.4 让 SSH 联接永久不超时<br>6.4.1 让 SSH 服务端的连接不超时</h4>



<p>（分别在电脑和 VPS 上执行以下步骤）</p>



<pre class="wp-block-code"><code># vim /etc/ssh/sshd_config</code></pre>



<p>将以下内容：</p>



<pre class="wp-block-code"><code>......
#ClientAliveInterval 0
#ClientAliveCountMax 3
......</code></pre>



<p>修改为：</p>



<pre class="wp-block-code"><code>......
ClientAliveInterval 60
ClientAliveCountMax 525600
......</code></pre>



<p>（补充：这样设置会让 SSH 服务端每 60s 就会尝试连接一次客户端，如果 525600 次后没有回应，则断开）</p>



<h4 id="6-4-2-让用户登陆永不超时6-4-2-1-在系统文件里添加让用户登陆永不超时的设置">6.4.2 让用户登陆永不超时<br>6.4.2.1 在系统文件里添加让用户登陆永不超时的设置</h4>



<p>（分别在电脑和 VPS 上执行以下步骤）</p>



<pre class="wp-block-code"><code># vim /etc/bashrc</code></pre>



<p>添加以下内容：</p>



<pre class="wp-block-code"><code>......
export TMOUT=0</code></pre>



<pre class="wp-block-code"><code># vim /etc/profile</code></pre>



<p>添加以下内容：</p>



<pre class="wp-block-code"><code>......
export TMOUT=0</code></pre>



<h4 id="6-4-2-2-让用户登陆永不超时的设置立刻生效">6.4.2.2 让用户登陆永不超时的设置立刻生效</h4>



<p>（分别在电脑和 VPS 上执行以下步骤）</p>



<pre class="wp-block-code"><code># source /etc/bashrc
# source /etc/profile</code></pre>



<h4 id="6-5-删除不需要的软件包以避免-cpu-占用过高而崩溃-选做">6.5 删除不需要的软件包以避免 CPU 占用过高而崩溃（选做）</h4>



<p>（步骤略）</p>



<h4 id="步骤七-搭建虚拟化平台">步骤七：搭建虚拟化平台</h4>



<p>（只在电脑上执行以下步骤）</p>



<pre class="wp-block-code"><code># yum -y install qemu-kvm libvirt-daemon libvirt-client libvirt-daemon-driver-qemu virt-install virt-manager virt-viewer virt-v2v</code></pre>



<h4 id="步骤八-实现文件共享8-1-安装-samba-服务">步骤八：实现文件共享<br>8.1 安装 Samba 服务</h4>



<p>（只在电脑上执行以下步骤）</p>



<pre class="wp-block-code"><code># yum -y install samba
</code></pre>



<h4 id="8-2-配置-samba-服务的配置文件">8.2 配置 Samba 服务的配置文件</h4>



<p>（只在电脑上执行以下步骤）</p>



<pre class="wp-block-code"><code># vim /etc/samba/smb.conf</code></pre>



<p>将全部内容修改如下：</p>



<pre class="wp-block-code"><code># See smb.conf.example for a more detailed config file or
# read the smb.conf manpage.
# Run 'testparm' to verify the config is correct after
# you modified it.

&#91;global]
workgroup = WORKGROUP
realm = zhumingyu
netbios name = zhumingyu
#encrypt passwords = yes
map to guest = NEVER
security = user
password server = *
name resolve order = bcast host
restrict anonymous = 2
#null passwords = no
#guest account = smb_nobody
#use spnego = yes
client use spnego = yes
server string = ""
host msdfs = no
msdfs root = no
domain master = no
preferred master = no
local master = no
os level = 0
browse list = no
browseable = no
dns proxy = no
wide links = no
public= no
guest ok = no
hosts deny = ALL EXCEPT 192.168.0.2

&#91;share]
valid users = zhumingyu
write list = zhumingyu
read list = zhumingyu
path = /share
guest ok = no
read only = no
browseable = no
writable = yes
public = no
create mask = 0755
directory mask = 0755</code></pre>



<p>（<br>补充：<br>1) 这里以 Samba 服务器的 IP 地址是 192.168.0.1 为例<br>2) 这里的 workgroup = WORKGROUP 是让 Samba 服务属于 WORKGROUP<br>3) 这里的 hosts deny = ALL EXCEPT 192.168.0.2 是只让客户端 192.168.0.3 能够访问服务端的 Samba<br>4) 这里的 sharetest 是这个 Samba 挂载点的名称，挂载这个挂载点的格式就是：//192.168.0.1/share<br>5) 这里的 valid users = zhumingyu 是 Samba 服务共享用户需要手动生成<br>6) 这里的 path = /share 是 Samba 服务共享目录需要手动生成<br>）</p>



<h4 id="8-3-设置-samba-服务共享用户8-3-1-给-samba-服务共享用户设置-samba-共享密码">8.3 设置 Samba 服务共享用户<br>8.3.1 给 Samba 服务共享用户设置 Samba 共享密码</h4>



<p>（只在电脑上执行以下步骤）</p>



<pre class="wp-block-code"><code># smbpasswd -a zhumingyu</code></pre>



<p>（补充：这里以用户 zhumingyu 为例）</p>



<h4 id="8-3-2-显示-samba-服务共享用户是否可用">8.3.2 显示 Samba 服务共享用户是否可用</h4>



<p>（只在电脑上执行以下步骤）</p>



<pre class="wp-block-code"><code># pdbedit -L</code></pre>



<h4 id="8-4-生成-samba-服务共享目录8-4-1-生成-samba-服务共享目录">8.4 生成 Samba 服务共享目录<br>8.4.1 生成 Samba 服务共享目录</h4>



<p>（只在电脑上执行以下步骤）</p>



<pre class="wp-block-code"><code># mkdir /share</code></pre>



<h4 id="8-4-2-给-samba-服务共享目录设置权限">8.4.2 给 Samba 服务共享目录设置权限</h4>



<p>（只在电脑上执行以下步骤）</p>



<pre class="wp-block-code"><code># chmod 755 /share/</code></pre>



<h4 id="8-4-3-给-samba-服务共享目录设置所属主和所属组">8.4.3 给 Samba 服务共享目录设置所属主和所属组</h4>



<p>（只在电脑上执行以下步骤）</p>



<pre class="wp-block-code"><code># chown zhumingyu:zhumingyu /share/</code></pre>



<p>（补充：这里以用户 zhumingyu 为例）</p>



<h4 id="8-4-4-给-samba-服务共享目录设置-selinux-标签">8.4.4 给 Samba 服务共享目录设置 selinux 标签</h4>



<p>（只在电脑上执行以下步骤）</p>



<pre class="wp-block-code"><code># semanage fcontext -a -t samba_share_t '/share(/.*)?'</code></pre>



<h4 id="8-4-5-让-samba-服务共享目录上的-selinux-标签立刻生效">8.4.5 让 Samba 服务共享目录上的 selinux 标签立刻生效</h4>



<p>（只在电脑上执行以下步骤）</p>



<pre class="wp-block-code"><code># restorecon -RFvv /share/</code></pre>



<h4 id="8-5-启动-samba-服务并设置为开机自动启动">8.5 启动 Samba 服务并设置为开机自动启动</h4>



<p>（只在电脑上执行以下步骤）</p>



<pre class="wp-block-code"><code># systemctl enable --now smb</code></pre>



<h4 id="8-6-在系统防火墙开放-samba-的端口8-6-1-在系统防火墙开放-samba-的端口">8.6 在系统防火墙开放 Samba 的端口<br>8.6.1 在系统防火墙开放 Samba 的端口</h4>



<p>（只在电脑上执行以下步骤）</p>



<pre class="wp-block-code"><code># firewall-cmd --add-service=samba --permanent</code></pre>



<h4 id="8-6-2-让系统防火墙重新加载">8.6.2 让系统防火墙重新加载</h4>



<p>（只在电脑上执行以下步骤）</p>



<pre class="wp-block-code"><code># firewall-cmd --reload</code></pre>



<h4 id="步骤九-实现远程桌面9-1-安装-vnc-服务">步骤九：实现远程桌面<br>9.1 安装 vnc 服务</h4>



<p>（只在电脑上执行以下步骤）</p>



<pre class="wp-block-code"><code># yum -y install tigervnc tigervnc-server</code></pre>



<h4 id="9-2-设置-vnc-服务共享用户9-2-1-进入用户">9.2 设置 VNC 服务共享用户<br>9.2.1 进入用户</h4>



<p>（只在电脑上执行以下步骤）</p>



<pre class="wp-block-code"><code># su - zhumingyu</code></pre>



<p>（补充：这里以用户 zhumingyu 为例）</p>



<h4 id="9-2-2-给-vnc-服务共享用户设置-vnc-远程密码">9.2.2 给 VNC 服务共享用户设置 VNC 远程密码</h4>



<p>（只在电脑上执行以下步骤）</p>



<pre class="wp-block-code"><code>$ vncpasswd</code></pre>



<h4 id="9-2-3-退出用户">9.2.3 退出用户</h4>



<p>（只在电脑上执行以下步骤）</p>



<pre class="wp-block-code"><code>$ exit</code></pre>



<h4 id="9-3-启动-vnc-并设置为开机自动启动9-3-1-创建开启-vnc-的脚本-vnc-sh9-3-1-1-进入到用户">9.3 启动 VNC 并设置为开机自动启动<br>9.3.1 创建开启 VNC 的脚本 ~/vnc.sh<br>9.3.1.1 进入到用户</h4>



<p>（只在电脑上执行以下步骤）</p>



<pre class="wp-block-code"><code># su - zhumingyu</code></pre>



<p>（补充：这里以用户 zhumingyu 为例）</p>



<h4 id="9-3-1-2-创建开启-vnc-的脚本-vnc-sh">9.3.1.2 创建开启 VNC 的脚本 ~/vnc.sh</h4>



<p>（只在电脑上执行以下步骤）</p>



<pre class="wp-block-code"><code>$ vim ~/vnc.sh</code></pre>



<p>创建以下内容：</p>



<pre class="wp-block-code"><code>#!/bin/bash

vncserver -list | grep :1 &amp;&gt; /dev/null || vncserver :1 -localhost -nolisten tcp</code></pre>



<p>（补充：此命令会检查 vncserver :1 会话是否存在，如果不存在，就以禁止非安全远程登陆的方式创建一个）</p>



<h4 id="9-3-1-3-退出用户">9.3.1.3 退出用户</h4>



<p>（只在电脑上执行以下步骤）</p>



<pre class="wp-block-code"><code>$ exit</code></pre>



<h4 id="9-3-2-执行开启-vnc-的脚本9-3-2-1-开机执行开启-vnc-的脚本9-3-2-1-1-配置开机执行的文件">9.3.2 执行开启 VNC 的脚本<br>9.3.2.1 开机执行开启 VNC 的脚本<br>9.3.2.1.1 配置开机执行的文件</h4>



<p>（只在电脑上执行以下步骤）</p>



<pre class="wp-block-code"><code># vim /etc/rc.local</code></pre>



<p>添加以下内容：</p>



<pre class="wp-block-code"><code>......
su - zhumingyu -c '/home/zhumingyu/vnc.sh'</code></pre>



<p>（补充：这里以用户 zhumingyu 的身份运行）</p>



<p>或者：</p>



<pre class="wp-block-code"><code>......
su - zhumingyu -c 'vncserver -list | grep :1' &amp;&gt; /dev/null || su - zhumingyu -c 'vncserver :1 -localhost -nolisten tcp'</code></pre>



<p>（<br>补充：<br>1) 如果前面没有创建脚本的话，可以只添加上面“或者”后面的这一行<br>2) 以用户 zhumingyu 的身份运行<br>3) 此命令会检查 vncserver :1 会话是否存在，如果不存在，就以禁止非安全远程登陆的方式创建一个<br>）</p>



<h4 id="9-3-2-1-2-给开机执行的文件执行权限">9.3.2.1.2 给开机执行的文件执行权限</h4>



<p>（只在电脑上执行以下步骤）</p>



<pre class="wp-block-code"><code># chmod u+x /home/zhumingyu/vnc.sh</code></pre>



<h4 id="9-3-2-2-定期执行开启-vnc-的脚本9-3-2-2-1-进入到用户">9.3.2.2 定期执行开启 VNC 的脚本<br>9.3.2.2.1 进入到用户</h4>



<pre class="wp-block-code"><code># su - zhumingyu</code></pre>



<p>（补充：这里以用户 zhumingyu 为例）</p>



<h4 id="9-3-2-2-2-配置定期执行的文件">9.3.2.2.2 配置定期执行的文件</h4>



<p>（只在电脑上执行以下步骤）</p>



<pre class="wp-block-code"><code>$ crontab -e</code></pre>



<p>添加以下内容：</p>



<pre class="wp-block-code"><code>......
0 */1 * * * /home/zhumingyu/vnc.sh</code></pre>



<p>或者：</p>



<pre class="wp-block-code"><code>......
0 */1 * * * vncserver -list | grep :1' &amp;&gt; /dev/null || su - zhumingyu -c 'vncserver :1 -localhost -nolisten tcp</code></pre>



<p>（<br>补充：<br>1) 这里以用户 zhumingyu 的身份运行<br>2) 如果前面没有创建脚本的话，可以只添加上面“或者”后面的这一行<br>3) 此命令会检查 vncserver :1 会话是否存在，如果不存在，就以禁止非安全远程登陆的方式创建一个<br>）</p>



<h4 id="9-3-2-2-3-退出用户">9.3.2.2.3 退出用户</h4>



<p>（只在电脑上执行以下步骤）</p>



<pre class="wp-block-code"><code>$ exit</code></pre>



<h4 id="步骤十-设置-ssh-内网穿透10-1-生成-ssh-密钥10-1-1-进入到用户">步骤十：设置 SSH 内网穿透<br>10.1 生成 SSH 密钥<br>10.1.1 进入到用户</h4>



<p>（分别在电脑、VPS 和客户端上执行以下步骤）</p>



<pre class="wp-block-code"><code># su - zhumingyu</code></pre>



<p>（补充：这里以用户 zhumingyu 为例）</p>



<h4 id="10-1-2-生成-ssh-密钥">10.1.2 生成 SSH 密钥</h4>



<p>（分别在电脑、VPS 和客户端上执行以下步骤）</p>



<pre class="wp-block-code"><code>$ ssh-keygen -b 2048 -t rsa</code></pre>



<p>（补充：建议在创建 SSH 密钥时为 SSH 密钥添加一个密码）</p>



<h4 id="10-1-3-退出用户">10.1.3 退出用户</h4>



<p>（分别在电脑、VPS 和客户端上执行以下步骤）</p>



<pre class="wp-block-code"><code>$ exit</code></pre>



<h4 id="10-2-实现无密钥-ssh10-2-1-进入到用户">10.2 实现无密钥 SSH<br>10.2.1 进入到用户</h4>



<p>（分别在电脑、VPS 和客户端上执行以下步骤）</p>



<pre class="wp-block-code"><code># su - zhumingyu</code></pre>



<p>（补充：这里以用户 zhumingyu 为例）</p>



<h4 id="10-2-2-让电脑可以无密钥-ssh-vps">10.2.2 让电脑可以无密钥 SSH VPS</h4>



<p>（只在电脑上执行以下步骤）</p>



<pre class="wp-block-code"><code>$ ssh-copy-id &lt;public IP address of VPS&gt;</code></pre>



<h4 id="10-2-3-让-vps-可以无密钥-ssh-自己">10.2.3 让 VPS 可以无密钥 SSH 自己</h4>



<p>（只在 VPS 上执行以下步骤）</p>



<pre class="wp-block-code"><code>$ ssh-copy-id localhost</code></pre>



<h4 id="10-2-4-让客户端可以远程-vps-和电脑">10.2.4 让客户端可以远程 VPS 和电脑</h4>



<pre class="wp-block-code"><code>$ ssh-copy-id &lt;IP address of computer&gt;
$ ssh-copy-id &lt;public IP address of VPS&gt;</code></pre>



<h4 id="10-2-5-退出用户">10.2.5 退出用户</h4>



<p>（分别在电脑、VPS 和客户端上执行以下步骤）</p>



<pre class="wp-block-code"><code>$ exit</code></pre>



<h4 id="10-3-建立电脑到-vps-的-ssh-隧道并设置为开机自启10-3-1-创建建立电脑到-vps-的-ssh-隧道的脚本-ssh-sh10-3-1-1-进入到用户">10.3 建立电脑到 VPS 的 SSH 隧道并设置为开机自启<br>10.3.1 创建建立电脑到 VPS 的 SSH 隧道的脚本 ～/ssh.sh<br>10.3.1.1 进入到用户</h4>



<p>（只在电脑上执行以下步骤）</p>



<pre class="wp-block-code"><code># su - zhumingyu</code></pre>



<p>（补充：这里以用户 zhumingyu 为例）</p>



<h4 id="10-3-1-2-创建建立电脑到-vps-的-ssh-隧道的脚本-ssh-sh">10.3.1.2 创建建立电脑到 VPS 的 SSH 隧道的脚本 ～/ssh.sh</h4>



<p>（只在电脑上执行以下步骤）</p>



<pre class="wp-block-code"><code>$ vim ～/ssh.sh</code></pre>



<p>创建以下内容：</p>



<pre class="wp-block-code"><code>ps -aux | grep -v grep | grep "11000:localhost:22 &lt;IP address of computer&gt;" &amp;&gt; /dev/null || ssh -X -fCNR 11000:localhost:22 &lt;IP address of computer&gt;</code></pre>



<p>（<br>补充：<br>1) 这里以用户 zhumingyu 的身份运行<br>2) 如果 11000 端口没有影射到 22 端口则影射<br>）</p>



<h4 id="10-3-1-3-退出用户">10.3.1.3 退出用户</h4>



<p>（只在电脑上执行以下步骤）</p>



<pre class="wp-block-code"><code>$ exit</code></pre>



<h4 id="10-3-2-执行电脑到-vps-的-ssh-隧道的脚本10-3-2-1-开机执行开启电脑到-vps-的-ssh-隧道的脚本10-3-2-1-1-配置开机执行的文件">10.3.2 执行电脑到 VPS 的 SSH 隧道的脚本<br>10.3.2.1 开机执行开启电脑到 VPS 的 SSH 隧道的脚本<br>10.3.2.1.1 配置开机执行的文件</h4>



<p>（只在电脑上执行以下步骤）</p>



<pre class="wp-block-code"><code># vim /etc/rc.local</code></pre>



<p>添加以下内容：</p>



<pre class="wp-block-code"><code>......
su - zhumingyu -c '/home/zhumingyu/ssh.sh'</code></pre>



<p>（补充：这里以用户 zhumingyu 的身份运行）</p>



<p>或者：</p>



<pre class="wp-block-code"><code>......
ps -aux | grep -v grep | grep "11000:localhost:22 &lt;IP address of computer&gt;" &amp;&gt; /dev/null || su - zhumingyu -c 'ssh -X -fCNR 11000:localhost:22 &lt;IP address of computer&gt;'</code></pre>



<p>（<br>补充：<br>1) 如果前面没有创建脚本的话，可以只添加上面“或者”后面的这一行<br>2) 这里以用户 zhumingyu 的身份运行<br>3) 如果 11000 端口没有影射到 22 端口则影射<br>）</p>



<h4 id="10-3-2-1-2-给开机执行的文件执行权限">10.3.2.1.2 给开机执行的文件执行权限</h4>



<p>（只在电脑上执行以下步骤）</p>



<pre class="wp-block-code"><code># chmod +x /etc/rc.local</code></pre>



<h4 id="10-3-3-定期执行电脑到-vps-的-ssh-隧道的脚本10-3-3-1-进入到用户">10.3.3 定期执行电脑到 VPS 的 SSH 隧道的脚本<br>10.3.3.1 进入到用户</h4>



<p>（只在电脑上执行以下步骤）</p>



<pre class="wp-block-code"><code># su - zhumingyu</code></pre>



<p>（补充：这里以 zhumingyu 为例）</p>



<h4 id="10-3-3-2-配置定期执行的文件">10.3.3.2 配置定期执行的文件</h4>



<p>（只在电脑上执行以下步骤）</p>



<pre class="wp-block-code"><code>$ crontab -e</code></pre>



<p>添加以下内容：</p>



<pre class="wp-block-code"><code>......
0 */1 * * * /home/zhumingyu/ssh.sh</code></pre>



<p>或者：</p>



<pre class="wp-block-code"><code>......
0 */1 * * * ps -aux | grep -v grep | grep "11000:localhost:22 &lt;IP address of computer&gt;" &amp;&gt; /dev/null || ssh -X -fCNR 11000:localhost:22 &lt;IP address of computer&gt;</code></pre>



<p>（补充：如果 11000 端口影射到 22 端口则影射）</p>



<h4 id="10-3-3-3-退出用户">10.3.3.3 退出用户</h4>



<p>（只在电脑上执行以下步骤）</p>



<pre class="wp-block-code"><code>$ exit</code></pre>



<h4 id="10-4-建立-vps-的-ssh-隧道端口映射并设置为开机自启10-4-1-创建建立-vps-的-ssh-隧道端口映射的脚本10-4-1-1-进入到用户">10.4 建立 VPS 的 SSH 隧道端口映射并设置为开机自启<br>10.4.1 创建建立 VPS 的 SSH 隧道端口映射的脚本<br>10.4.1.1 进入到用户</h4>



<p>（只在 VPS 上执行以下步骤）</p>



<pre class="wp-block-code"><code># su - zhumingyu</code></pre>



<p>（补充：这里以用户 zhumingyu 为例）</p>



<h4 id="10-4-1-2-创建建立-vps-的-ssh-隧道端口映射的脚本">10.4.1.2 创建建立 VPS 的 SSH 隧道端口映射的脚本</h4>



<p>（只在 VPS 上执行以下步骤）</p>



<pre class="wp-block-code"><code>$ vim ~/sshd.sh</code></pre>



<p>创建以下内容：</p>



<pre class="wp-block-code"><code>#!/bin/bash

ps -aux | grep -v grep | grep "*:10000:localhost:11000 localhost" || ssh -X -fCNL *:10000:localhost:11000 localhost</code></pre>



<p>（补充：如果 11000 端口没有影射成 10000 端口则影射）</p>



<h4 id="10-4-1-3-退出用户">10.4.1.3 退出用户</h4>



<p>（只在 VPS 上执行以下步骤）</p>



<pre class="wp-block-code"><code>$ exit</code></pre>



<h4 id="10-4-2-执行电脑到-vps-的-ssh-隧道的脚本10-4-2-1-开机执行开启电脑到-vps-的-ssh-隧道的脚本10-4-2-1-1-配置开机执行的文件">10.4.2 执行电脑到 VPS 的 SSH 隧道的脚本<br>10.4.2.1 开机执行开启电脑到 VPS 的 SSH 隧道的脚本<br>10.4.2.1.1 配置开机执行的文件</h4>



<p>（只在 VPS 上执行以下步骤）</p>



<pre class="wp-block-code"><code># vim /etc/rc.local</code></pre>



<p>添加以下内容：</p>



<pre class="wp-block-code"><code>......
su - zhumingyu -c '/home/zhumingyu/sshd.sh'</code></pre>



<p>（补充：这里以用户 zhumingyu 为例）</p>



<p>或者：</p>



<pre class="wp-block-code"><code>......
ps -aux | grep -v grep | grep "*:10000:localhost:11000 localhost" || su - zhumingyu -c 'ssh -X -fCNL *:10000:localhost:11000 localhost'</code></pre>



<p>（<br>补充：<br>1) 如果前面没有创建脚本的话，可以只添加上面“或者”后面的这一行<br>2) 以用户 zhumingyu 的身份运行<br>3) 如果 11000 端口没有影射成 10000 端口则影射<br>）</p>



<h4 id="10-4-2-1-2-给开机执行的文件执行权限">10.4.2.1.2 给开机执行的文件执行权限</h4>



<p>（只在 VPS 上执行以下步骤）</p>



<pre class="wp-block-code"><code># chmod +x /etc/rc.local</code></pre>



<h4 id="10-4-3-定期执行电脑到-vps-的-ssh-隧道的脚本10-4-3-1-进入到用户用户">10.4.3 定期执行电脑到 VPS 的 SSH 隧道的脚本<br>10.4.3.1 进入到用户用户</h4>



<p>（只在 VPS 上执行以下步骤）</p>



<pre class="wp-block-code"><code># su - zhumingyu</code></pre>



<p>（补充：这里以用户 zhumingyu 为例）</p>



<h4 id="10-4-3-2-配置定期执行的文件">10.4.3.2 配置定期执行的文件</h4>



<p>（只在 VPS 上执行以下步骤）</p>



<pre class="wp-block-code"><code>$ crontab -e</code></pre>



<p>添加以下内容：</p>



<pre class="wp-block-code"><code>......
0 */1 * * * /home/zhumingyu/sshd.sh</code></pre>



<p>或者：</p>



<pre class="wp-block-code"><code>......
0 */1 * * * ps -aux | grep -v grep | grep "*:10000:localhost:11000 localhost" || ssh -X -fCNL *:10000:localhost:11000 localhost</code></pre>



<p>（<br>补充：<br>1) 如果前面没有创建脚本的话，可以只添加上面“或者”后面的这一行<br>2) 如果 11000 端口没有影射成 10000 端口则影射<br>）</p>



<h4 id="10-4-4-退出用户">10.4.4 退出用户</h4>



<p>（只在 VPS 上执行以下步骤）</p>



<pre class="wp-block-code"><code>$ exit</code></pre>



<h4 id="10-4-5-打开外网-vps-对应端口的防火墙10-4-5-1-打开外网-vps-对应端口的防火墙">10.4.5 打开外网 VPS 对应端口的防火墙<br>10.4.5.1 打开外网 VPS 对应端口的防火墙</h4>



<p>（只在 VPS 上执行以下步骤）</p>



<pre class="wp-block-code"><code># firewall-cmd --add-port=10000/tcp --permanent</code></pre>



<p>（补充：这里打开的端口号，是根据前面的设置而定的）</p>



<h4 id="10-4-5-2-让刚刚外网-vps-刚刚配置的防火墙生效">10.4.5.2 让刚刚外网 VPS 刚刚配置的防火墙生效</h4>



<p>（只在 VPS 上执行以下步骤）</p>



<pre class="wp-block-code"><code># firewall-cmd --reload</code></pre>



<h4 id="步骤十一-加强-ssh-的安全性-选做-11-1-禁止-root-被-ssh-选做">步骤十一：加强 SSH 的安全性（选做）<br>11.1 禁止 root 被 SSH（选做）</h4>



<p>（分别在电脑和 VPS 上执行以下步骤）</p>



<pre class="wp-block-code"><code># vim /etc/ssh/sshd_config</code></pre>



<p>将以下内容：</p>



<pre class="wp-block-code"><code>......
PermitRootLogin no
......</code></pre>



<p>修改为：</p>



<pre class="wp-block-code"><code>......
PermitRootLogin yes
......</code></pre>



<h4 id="11-2-禁止使用密码被-ssh-选做">11.2 禁止使用密码被 SSH（选做）</h4>



<p>（分别在电脑和 VPS 上执行以下步骤）</p>



<pre class="wp-block-code"><code># vim /etc/ssh/sshd_config</code></pre>



<p>将以下内容：</p>



<pre class="wp-block-code"><code>......
# PasswordAuthentication yes
......</code></pre>



<p>修改为：</p>



<pre class="wp-block-code"><code>......
PasswordAuthentication no
......</code></pre>



<h4 id="步骤十二-私有远程桌面和虚拟化平台的使用12-1-客户端-ssh-联接电脑的方法12-1-1-客户端和电脑不在同一内网时">步骤十二：私有远程桌面和虚拟化平台的使用<br>12.1 客户端 SSH 联接电脑的方法<br>12.1.1 客户端和电脑不在同一内网时</h4>



<p>（只在客户端上执行以下步骤）</p>



<pre class="wp-block-code"><code># ssh -X -p &lt;SSH non standard port number&gt; &lt;user of computer&gt;@&lt;public IP address of VPS&gt;</code></pre>



<p>（<br>补充：<br>1) 如果按照前面的步骤操作，这里的 VPS 每小时会生成一个新的 SSH 非标准端口号以用于联接电脑，比如说现在是 14 点，那就会自动生成一个 11014 的 SSH 非标准端口号<br>2) 如果按照前面的步骤操作，这里的用户是 zhumingyu<br>）</p>



<h4 id="12-1-2-客户端和电脑在同一内网时">12.1.2 客户端和电脑在同一内网时</h4>



<p>（只在客户端上执行以下步骤）</p>



<pre class="wp-block-code"><code># ssh -X &lt;user of computer&gt;@&lt;IP address of computer&gt;</code></pre>



<p>（<br>补充：<br>1) 如果按照前面的步骤操作，这里的用户用户是 zhumingyu<br>2) 如果按照前面的步骤操作，这里的电脑的 IP 地址是 192.168.0.1<br>）</p>



<h4 id="12-2-客户端使用电脑虚拟化平台的的方法12-2-1-客户端和电脑不在同一内网时12-2-1-1-在客户端上联接电脑">12.2 客户端使用电脑虚拟化平台的的方法<br>12.2.1 客户端和电脑不在同一内网时<br>12.2.1.1 在客户端上联接电脑</h4>



<p>（只在客户端上执行以下步骤）</p>



<pre class="wp-block-code"><code># ssh -X -p &lt;SSH non standard port number&gt; &lt;user of computer&gt;@&lt;public IP address of VPS&gt;</code></pre>



<p>（<br>补充：<br>1) 如果按照前面的步骤操作，这里的 VPS 每小时会生成一个新的 SSH 非标准端口号以用于联接电脑，比如说现在是 14 点，那就会自动生成一个 11014 的 SSH 非标准端口号<br>2) 如果按照前面的步骤操作，这里的用户用户是 zhumingyu<br>）</p>



<h4 id="12-2-1-2-通过-ssh-开启虚拟化图形管理平台">12.2.1.2 通过 ssh 开启虚拟化图形管理平台</h4>



<p>（只在客户端上执行以下步骤）</p>



<pre class="wp-block-code"><code># virt-manager</code></pre>



<p>（注意：网络带宽很小则远程桌面会比较卡，建议电脑、客户端和 VPS 的带宽 2m 以上）</p>



<h4 id="12-2-2-客户端和电脑在同一内网时12-2-2-1-在客户端上联接电脑">12.2.2 客户端和电脑在同一内网时<br>12.2.2.1 在客户端上联接电脑</h4>



<p>（只在客户端上执行以下步骤）</p>



<pre class="wp-block-code"><code># ssh -X &lt;user of computer&gt;@&lt;IP address of computer&gt;</code></pre>



<p>（<br>补充：<br>1) 如果按照前面的步骤操作，这里的用户用户是 zhumingyu<br>2) 如果按照前面的步骤操作，这里的电脑的 IP 地址是 192.168.0.1<br>）</p>



<h4 id="12-2-2-2-通过-ssh-开启虚拟化图形管理平台">12.2.2.2 通过 ssh 开启虚拟化图形管理平台</h4>



<p>（只在客户端上执行以下步骤）</p>



<pre class="wp-block-code"><code># virt-manager</code></pre>



<p>（注意：网络带宽很小则远程桌面会比较卡，建议电脑、客户端和 VPS 的带宽 2m 以上）</p>



<h4 id="12-3-客户端使用私有远程桌面的方法12-3-1-客户端和电脑不在同一内网时">12.3 客户端使用私有远程桌面的方法<br>12.3.1 客户端和电脑不在同一内网时</h4>



<p>（只在客户端上执行以下步骤）</p>



<pre class="wp-block-code"><code># ssh -p &lt;SSH non standard port number&gt; -L &lt;port number of VNC&gt;:localhost:&lt;port number of VNC&gt; -l &lt;user of computer&gt; &lt;public IP address of VPS&gt;</code></pre>



<p>（<br>补充：<br>1) 如果按照前面的步骤操作，这里的 VPS 每小时会生成一个新的 SSH 非标准端口号以用于联接电脑，比如说现在是 14 点，那就会自动生成一个 11014 的 SSH 非标准端口号<br>2) 如果按照前面的步骤操作，这里的 VNC 的端口号是 5901<br>3) 如果按照前面的步骤操作，这里的电脑的用户用户是 zhumingyu<br>）</p>



<p>另开启一个命令行终端：</p>



<pre class="wp-block-code"><code># vncviewer localhost :&lt;number of VNC service&gt;</code></pre>



<p>（补充：如果按照前面的步骤操作，这里的 VNC 服务的编号是 1）</p>



<p>（注意：网络带宽很小则远程桌面会比较卡，建议电脑、客户端和 VPS 的带宽 2m 以上）</p>



<h4 id="12-3-2-客户端和电脑在同一内网时">12.3.2 客户端和电脑在同一内网时</h4>



<p>（只在客户端上执行以下步骤）</p>



<pre class="wp-block-code"><code># vncviewer -via &lt;user of computer&gt;@&lt;IP address of computer&gt; localhost :&lt;number of VNC service&gt;</code></pre>



<p>（<br>补充：<br>1) 如果按照前面的步骤操作，这里的电脑的用户是 zhumingyu<br>2) 如果按照前面的步骤操作，这里的电脑的 IP 地址是 192.168.0.1<br>3) 如果按照前面的步骤操作，这里的 VNC 服务的编号是 1<br>）</p>



<h4 id="12-4-客户端在内网和电脑互传数据的方法12-4-1-在-windows-图形客户端上和电脑互传数据的方法">12.4 客户端在内网和电脑互传数据的方法<br>12.4.1 在 Windows 图形客户端上和电脑互传数据的方法</h4>



<p>（只在客户端上执行以下步骤）</p>



<p>在文件目录下栏输入以下内容：</p>



<pre class="wp-block-code"><code>\\&lt;IP address of computer&gt;\&lt;samba directory&gt;</code></pre>



<p>（<br>补充：<br>1) 如果按照前面的步骤操作，这里的电脑的 IP 地址是 192.168.0.1<br>2) 如果按照前面的步骤操作，这里的 Samba 项目是 share<br>）</p>



<p>（<br>注意：<br>1) 如果按照前面的步骤操作，只有 IP 地址是 192.168.0.2 和 192.168.0.3 的客户端才能够执行以上步骤<br>2) Windows 客户端建议安装 SecureCRT、Xmanager 和 VNC 客户端以实现 ssh、ssh 调用 virt-manager 和 VNC<br>）</p>



<h4 id="12-4-2-在-linux-图形客户端上和电脑互传数据的方法">12.4.2 在 Linux 图形客户端上和电脑互传数据的方法</h4>



<p>（只在客户端上执行以下步骤）</p>



<p>在文件 &#8211;&gt; 其他位置 &#8211;&gt; 连接到服务器的地址栏里输入以下内容：</p>



<pre class="wp-block-code"><code>smb://&lt;IP address of computer&gt;/&lt;samba directory&gt;</code></pre>



<p>（<br>补充：<br>1) 如果按照前面的步骤操作，这里的电脑的 IP 地址是 192.168.0.1<br>2) 如果按照前面的步骤操作，这里的 Samba 项目是 share<br>）</p>



<p>（注意：如果按照前面的步骤操作，只有 IP 地址是 192.168.0.2 和 192.168.0.3 的客户端才能够执行以上步骤）</p>



<h4 id="步骤十三-客户端直接使用公网-ip-地址联接电脑13-1-实现此步骤所需环境">步骤十三：客户端直接使用公网 IP 地址联接电脑<br>13.1 实现此步骤所需环境</h4>



<p>网关路由器拥有 IP 地址（可以通过给宽带申请公网 IP 地址并将光纤盒设置为桥接模式，在路由器上添加用户和密码实现）</p>



<h4 id="13-2-在路由器上将电脑上的-22-端口映射到路由器上的公网-ip-地址上-这样路由器上的公网-ip-地址就变成电脑的公网-ip-地址了">13.2 在路由器上将电脑上的 22 端口映射到路由器上的公网 IP 地址上，这样路由器上的公网 IP 地址就变成电脑的公网 IP 地址了</h4>



<p>（步骤略）</p>



<h4 id="13-3-将电脑的公网-ip-地址放到-vps-上13-3-1-将电脑的公网-ip-地址放到-vps-上的意义">13.3 将电脑的公网 IP 地址放到 VPS 上<br>13.3.1 将电脑的公网 IP 地址放到 VPS 上的意义</h4>



<p>由于大多数的公网 IP 地址都是动态，定期会变，所以可以通过此方法知道近期的公网 IP 地址是多少</p>



<h4 id="13-3-2-创建将电脑的公网-ip-地址放到-vps-上的脚本13-3-2-1-进入到用户">13.3.2 创建将电脑的公网 IP 地址放到 VPS 上的脚本<br>13.3.2.1 进入到用户</h4>



<p>（只在电脑上执行以下步骤）</p>



<pre class="wp-block-code"><code># su - zhumingyu</code></pre>



<p>（补充：这里以用户 zhumingyu 为例）</p>



<h4 id="13-3-2-2-创建将电脑的公网-ip-地址放到-vps-上的脚本">13.3.2.2 创建将电脑的公网 IP 地址放到 VPS 上的脚本</h4>



<p>（只在电脑上执行以下步骤）</p>



<pre class="wp-block-code"><code>$ vim /root/computerip.sh</code></pre>



<p>创建以下内容：</p>



<pre class="wp-block-code"><code>#!/bin/bash

computerip=`curl ifconfig.me`
domain=&lt;public IP address of VPS&gt;

ssh athenadb.com \"echo `curl ifconfig.me` &gt; /home/zhumingyu/serverip.txt\"</code></pre>



<p>（补充：将电脑的公网 IP 地址拷贝到 VPS 的 /tmp/computerip.txt 文件里为例）</p>



<h4 id="13-3-2-3-退出用户用户">13.3.2.3 退出用户用户</h4>



<p>（只在电脑上执行以下步骤）</p>



<pre class="wp-block-code"><code>$ exit</code></pre>



<h4 id="13-3-3-执行将电脑的公网-ip-地址放到-vps-上的脚本13-3-3-1-进入到用户用户">13.3.3 执行将电脑的公网 IP 地址放到 VPS 上的脚本<br>13.3.3.1 进入到用户用户</h4>



<p>（只在电脑上执行以下步骤）</p>



<pre class="wp-block-code"><code># su - zhumingyu</code></pre>



<p>（补充：这里以用户 zhumingyu 为例）</p>



<h4 id="13-3-3-2-配置定期执行的文件">13.3.3.2 配置定期执行的文件</h4>



<p>（只在电脑上执行以下步骤）</p>



<pre class="wp-block-code"><code>$ crontab -e</code></pre>



<p>添加以下内容：</p>



<pre class="wp-block-code"><code>......
0 */10 * * * /home/zhumingyu/.crontab/computerip.txt</code></pre>



<p>或者：</p>



<pre class="wp-block-code"><code>......
ssh &lt;public IP address of VPS&gt; \"echo `curl ifconfig.me` &gt; /home/zhumingyu/serverip.txt\"</code></pre>



<p>（<br>补充：<br>1) 如果前面没有创建脚本的话，可以只添加上面“或者”后面的这一行<br>2) 将电脑的公网 IP 地址拷贝到 VPS 的 /home/zhumingyu/serverip.txt 文件里<br>）</p>



<h4 id="13-3-3-3-退出用户用户">13.3.3.3 退出用户用户</h4>



<p>（只在电脑上执行以下步骤）</p>



<pre class="wp-block-code"><code>$ exit</code></pre>



<h4 id="13-4-通过-ddns-服务显示电脑的公网-ip13-4-1-通过-ddns-服务显示电脑的公网-ip">13.4 通过 DDNS 服务显示电脑的公网 IP<br>13.4.1 通过 DDNS 服务显示电脑的公网 IP</h4>



<p>由于大多数的公网 IP 地址都是动态，定期会变，所以可以通过此方法知道近期的公网 IP 地址是多少</p>



<h4 id="13-4-2-有些-ddns-服务可以在网关路由器上设置-并且通过手机-app-显示现在的公网-ip-地址">13.4.2 有些 DDNS 服务可以在网关路由器上设置，并且通过手机 APP 显示现在的公网 IP 地址</h4>



<p>（步骤略）</p>
]]></content:encoded>
					
		
		
			</item>
		<item>
		<title>[内容] VNC 数据的加密 （通过 SSH 实现）</title>
		<link>https://eternalcenter-2022-02.github.io/vnc-ssh/</link>
		
		<dc:creator><![CDATA[Mingyu Zhu]]></dc:creator>
		<pubDate>Mon, 21 Sep 2020 14:56:43 +0000</pubDate>
				<category><![CDATA[Chinese (中文)]]></category>
		<category><![CDATA[Other Services (其他服务)]]></category>
		<category><![CDATA[Services (服务)]]></category>
		<category><![CDATA[System (系统)]]></category>
		<category><![CDATA[System Login Security (系统登录安全)]]></category>
		<category><![CDATA[System Network & System Security & System Log (系统网络 & 系统安全 & 系统日志)]]></category>
		<category><![CDATA[System Port Security (系统端口安全)]]></category>
		<category><![CDATA[System Security (系统安全)]]></category>
		<category><![CDATA[VNC]]></category>
		<guid isPermaLink="false">https://eternalcenter-2022-02.github.io/?p=10572</guid>

					<description><![CDATA[内容目录： 内容一：直接通过 SSH 对 VNC 进行加密1.1 直接通过 SSH 对 VNC 进行加密的格式1.2 直接通过 SSH 对 VNC 进行加密的案例 内容二：通过非标准端口的 SSH 对 VNC 进行加密2.1 通过 SSH 对 VNC 进行加密，同时使用 SSH 隧道的格式2.2 通过 SSH 对 VNC 进行加密，同时使用 SSH 隧道的案例 具体的内容： 内容一：直接通过 SSH 对 VNC 进行加密1.1 直接通过 SSH 对 VNC 进行加密的格式 1.2 直接通过 SSH 对 VNC 进行加密的案例 （补充：这里以使用 eternalcenter.com 服务器上的 &#8230; <p class="link-more"><a href="https://eternalcenter-2022-02.github.io/vnc-ssh/" class="more-link">Continue reading<span class="screen-reader-text"> "[内容] VNC 数据的加密 （通过 SSH 实现）"</span></a></p>]]></description>
										<content:encoded><![CDATA[
<h2>内容目录：</h2>



<h4>内容一：直接通过 SSH 对 VNC 进行加密<br>1.1 直接通过 SSH 对 VNC 进行加密的格式<br>1.2 直接通过 SSH 对 VNC 进行加密的案例</h4>



<h4>内容二：通过非标准端口的 SSH 对 VNC 进行加密<br>2.1 通过 SSH 对 VNC 进行加密，同时使用 SSH 隧道的格式<br>2.2 通过 SSH 对 VNC 进行加密，同时使用 SSH 隧道的案例</h4>



<h2>具体的内容：</h2>



<h4>内容一：直接通过 SSH 对 VNC 进行加密<br>1.1 直接通过 SSH 对 VNC 进行加密的格式</h4>



<pre class="wp-block-code"><code># vncviewer -via &lt;SSH user of VNC server>@&lt;IP address of VNC server> localhost :&lt;VNC service number></code></pre>



<h4>1.2 直接通过 SSH 对 VNC 进行加密的案例</h4>



<pre class="wp-block-code"><code># vncviewer -via zhumingyu@eternalcenter.com localhost :1</code></pre>



<p>（补充：这里以使用 eternalcenter.com 服务器上的 zhumingyu 用户访问编号为 1 的 VNC 服务为例）</p>



<h4>内容二：通过非标准端口的 SSH 对 VNC 进行加密<br>2.1 通过 SSH 对 VNC 进行加密，同时使用 SSH 隧道的格式</h4>



<pre class="wp-block-code"><code># ssh -p &lt;SSH non standard port number> -L &lt;Port number of VNC service>:localhost:&lt;Port number of VNC service> -l  &lt;SSH user of VNC server> &lt;IP address of VNC server></code></pre>



<p>另开启一个命令行终端：</p>



<pre class="wp-block-code"><code># vncviewer localhost :&lt;VNC service number></code></pre>



<h4>2.2 通过 SSH 对 VNC 进行加密，同时使用 SSH 隧道的案例</h4>



<pre class="wp-block-code"><code># ssh -p 1000 -L 5901:localhost:5901 -l zhumingyu eternalcenter.com</code></pre>



<p>另开启一个命令行终端：</p>



<pre class="wp-block-code"><code># vncviewer localhost :1</code></pre>



<p>（补充：这里以使用 eternalcenter.com 服务器上的 zhumingyu 用户通过 1000 端口号 的 SSH 访问编号为 1 的 VNC 服务为例）</p>
]]></content:encoded>
					
		
		
			</item>
		<item>
		<title>[实验] Samba 远程共享服务的搭建</title>
		<link>https://eternalcenter-2022-02.github.io/samba-build/</link>
		
		<dc:creator><![CDATA[Mingyu Zhu]]></dc:creator>
		<pubDate>Fri, 24 Jul 2020 07:40:08 +0000</pubDate>
				<category><![CDATA[Chinese (中文)]]></category>
		<category><![CDATA[Other Services (其他服务)]]></category>
		<category><![CDATA[Samba]]></category>
		<category><![CDATA[Services (服务)]]></category>
		<category><![CDATA[Storage Services (存储服务)]]></category>
		<category><![CDATA[纪念 Anniversary]]></category>
		<guid isPermaLink="false">https://eternalcenter-2022-02.github.io/?p=10243</guid>

					<description><![CDATA[纪念：站主于 2020 年 7 月完成了此开源实验，并将过程中的所有命令经过整理和注释以后，形成以下教程 步骤目录： 步骤一：规划拓扑1.1 服务器列表1.2 服务器列表简介 步骤二：系统环境要求 步骤三：在服务端上安装 Samba 服务 步骤四：在服务端上配置 Samba 服务4.1 在服务端上配置 Samba 服务文件4.2 在服务端上生成 Samba 服务共享用户4.2.1 在服务端上生成 Samba 服务共享用户4.2.2 在服务端上给 Samba 服务共享用户设置系统密码4.2.3 在服务端上给 Samba 服务共享用户设置 Samba 共享密码4.2.4 显示 Samba 服务共享用户是否可用4.3 在服务端上生成 Samba 服务共享目录4.3.1 在服务端上生成 Samba 服务共享目录4.3.2 在服务端上给 Samba 服务共享目录设置权限4.3.3 在服务端上给 Samba 服务共享目录设置所属主和所属组4.3.4 在服务端上给 Samba 服务共享目录设置 selinux 标签4.3.5 在服务端上让 Samba &#8230; <p class="link-more"><a href="https://eternalcenter-2022-02.github.io/samba-build/" class="more-link">Continue reading<span class="screen-reader-text"> "[实验] Samba 远程共享服务的搭建"</span></a></p>]]></description>
										<content:encoded><![CDATA[
<p class="has-vivid-red-color has-text-color has-medium-font-size"><strong>纪念：站主于 2020 年 7 月完成了此开源实验，并将过程中的所有命令经过整理和注释以后，形成以下教程</strong></p>



<h2 id="步骤目录">步骤目录：</h2>



<h4 id="步骤一-规划拓扑1-1-服务器列表1-2-服务器列表简介">步骤一：规划拓扑<br>1.1 服务器列表<br>1.2 服务器列表简介</h4>



<h4 id="步骤二-系统环境要求">步骤二：系统环境要求</h4>



<h4 id="步骤三-在服务端上安装-samba-服务">步骤三：在服务端上安装 Samba 服务</h4>



<h4 id="步骤四-在服务端上配置-samba-服务4-1-在服务端上配置-samba-服务文件4-2-在服务端上生成-samba-服务共享用户4-2-1-在服务端上生成-samba-服务共享用户4-2-2-在服务端上给-samba-服务共享用户设置系统密码4-2-3-在服务端上给-samba-服务共享用户设置-samba-共享密码4-2-4-显示-samba-服务共享用户是否可用4-3-在服务端上生成-samba-服务共享目录4-3-1-在服务端上生成-samba-服务共享目录4-3-2-在服务端上给-samba-服务共享目录设置权限4-3-3-在服务端上给-samba-服务共享目录设置所属主和所属组4-3-4-在服务端上给-samba-服务共享目录设置-selinux-标签4-3-5-在服务端上让-samba-服务共享目录上的-selinux-标签立刻生效">步骤四：在服务端上配置 Samba 服务<br>4.1 在服务端上配置 Samba 服务文件<br>4.2 在服务端上生成 Samba 服务共享用户<br>4.2.1 在服务端上生成 Samba 服务共享用户<br>4.2.2 在服务端上给 Samba 服务共享用户设置系统密码<br>4.2.3 在服务端上给 Samba 服务共享用户设置 Samba 共享密码<br>4.2.4 显示 Samba 服务共享用户是否可用<br>4.3 在服务端上生成 Samba 服务共享目录<br>4.3.1 在服务端上生成 Samba 服务共享目录<br>4.3.2 在服务端上给 Samba 服务共享目录设置权限<br>4.3.3 在服务端上给 Samba 服务共享目录设置所属主和所属组<br>4.3.4 在服务端上给 Samba 服务共享目录设置 selinux 标签<br>4.3.5 在服务端上让 Samba 服务共享目录上的 selinux 标签立刻生效</h4>



<h4 id="步骤五-启动-samba-服务并设置为开机自动启动">步骤五：启动 Samba 服务并设置为开机自动启动</h4>



<h4 id="步骤六-客户端使用服务端-samba-服务6-1-在客户端上安装-samba-客户端软件6-2-在客户端上测试服务端的-samba-服务6-3-在客户端上挂载服务端的-samba-目录6-3-1-手动挂载的方法6-3-2-自动挂载的方法">步骤六：客户端使用服务端 Samba 服务<br>6.1 在客户端上安装 Samba 客户端软件<br>6.2 在客户端上测试服务端的 Samba 服务<br>6.3 在客户端上挂载服务端的 Samba 目录<br>6.3.1 手动挂载的方法<br>6.3.2 自动挂载的方法</h4>



<h2 id="具体的操作步骤">具体的操作步骤：</h2>



<h4 id="步骤一-规划拓扑1-1-服务器列表">步骤一：规划拓扑<br>1.1 服务器列表</h4>



<p>服务端 192.168.101.41<br>客户端 192.168.101.42</p>



<h4 id="1-2-服务器列表简介">1.2 服务器列表简介</h4>



<p>1) 服务器提供 Samba 服务将自己的目录分享<br>2) 客户端挂载和使用 Samba 服务将服务端分享的目录挂载在自己的目录上</p>



<h4 id="步骤二-系统环境要求">步骤二：系统环境要求</h4>



<p>1) 所有服务器的系统都需要是 CentOS 8 版本<br>2) 所有服务器都要关闭防火墙<br>3) 所有服务器都要打开 SELinux<br>4) 所有服务器系统都要配置好可用的软件源<br>5) 需要按照拓扑图给对应的服务器配置好 IP 地址和主机名<br>6) 所有服务器都要可以相互 ping 通自己和对方的 IP 地址和主机名</p>



<h4 id="步骤三-在服务端上安装-samba-服务">步骤三：在服务端上安装 Samba 服务</h4>



<p>（只在服务端上执行以下步骤）</p>



<pre class="wp-block-code"><code># yum -y install samba</code></pre>



<h4 id="步骤四-在服务端上配置-samba-服务4-1-在服务端上配置-samba-服务文件">步骤四：在服务端上配置 Samba 服务<br>4.1 在服务端上配置 Samba 服务文件</h4>



<p>（只在服务端上执行以下步骤）</p>



<pre class="wp-block-code"><code># vim /etc/samba/smb.conf</code></pre>



<p>将全部内容修改如下：</p>



<pre class="wp-block-code"><code># See smb.conf.example for a more detailed config file or
# read the smb.conf manpage.
# Run 'testparm' to verify the config is correct after
# you modified it.

&#91;global]
workgroup = WORKGROUP
realm = zhumingyu
netbios name = zhumingyu
#encrypt passwords = yes
map to guest = NEVER
security = user
password server = *
name resolve order = bcast host
restrict anonymous = 2
#null passwords = no
#guest account = smb_nobody
#use spnego = yes
client use spnego = yes
server string = ""
host msdfs = no
msdfs root = no
domain master = no
preferred master = no
local master = no
os level = 0
browse list = no
browseable = no
dns proxy = no
wide links = no
public= no
guest ok = no
hosts deny = ALL EXCEPT 192.168.101.42

&#91;sharetest]
valid users = zhumingyu
write list = zhumingyu
read list = zhumingyu
path = /share
guest ok = no
read only = no
browseable = no
writable = yes
public = no
create mask = 0755
directory mask = 0755</code></pre>



<p>（<br>补充：<br>1) 这里的 workgroup = WORKGROUP 是让 Samba 服务属于 WORKGROUP<br>2) 这里的 hosts deny = ALL EXCEPT 192.168.101.42 是只让客户端 192.168.101.42 能够访问服务端的 Samba<br>3) 这里的 sharetest 是这个 Samba 挂载点的名称，挂载这个挂载点的格式就是：//192.168.101.41/sharetest<br>4) 这里的 valid users = zhumingyu 是 Samba 服务共享用户需要手动生成，如果换成让所有的服务共享用户都可以使用则可以写成 valid users = @users<br>5) 这里的 path = /share 是 Samba 服务共享目录需要手动生成<br>）</p>



<h4 id="4-2-在服务端上生成-samba-服务共享用户4-2-1-在服务端上生成-samba-服务共享用户">4.2 在服务端上生成 Samba 服务共享用户<br>4.2.1 在服务端上生成 Samba 服务共享用户</h4>



<p>（只在服务端上执行以下步骤）</p>



<pre class="wp-block-code"><code># useradd zhumingyu</code></pre>



<h4 id="4-2-2-在服务端上给-samba-服务共享用户设置系统密码">4.2.2 在服务端上给 Samba 服务共享用户设置系统密码</h4>



<pre class="wp-block-code"><code>（只在服务端上执行以下步骤）</code></pre>



<pre class="wp-block-code"><code># passwd zhumingyu</code></pre>



<h4 id="4-2-3-在服务端上给-samba-服务共享用户设置-samba-共享密码">4.2.3 在服务端上给 Samba 服务共享用户设置 Samba 共享密码</h4>



<p>（只在服务端上执行以下步骤）</p>



<pre class="wp-block-code"><code># smbpasswd -a zhumingyu</code></pre>



<h4 id="4-2-4-显示samba-服务共享用户是否可用">4.2.4 显示Samba 服务共享用户是否可用</h4>



<p>（只在服务端上执行以下步骤）</p>



<pre class="wp-block-code"><code># pdbedit -L</code></pre>



<h4 id="4-3-在服务端上生成-samba-服务共享目录4-3-1-在服务端上生成-samba-服务共享目录">4.3 在服务端上生成 Samba 服务共享目录<br>4.3.1 在服务端上生成 Samba 服务共享目录</h4>



<p>（只在服务端上执行以下步骤）</p>



<pre class="wp-block-code"><code># mkdir /share</code></pre>



<h4 id="4-3-2-在服务端上给-samba-服务共享目录设置权限">4.3.2 在服务端上给 Samba 服务共享目录设置权限</h4>



<p>（只在服务端上执行以下步骤）</p>



<pre class="wp-block-code"><code># chmod 755 /share/</code></pre>



<h4 id="4-3-3-在服务端上给-samba-服务共享目录设置所属主和所属组">4.3.3 在服务端上给 Samba 服务共享目录设置所属主和所属组</h4>



<p>（只在服务端上执行以下步骤）</p>



<pre class="wp-block-code"><code># chown zhumingyu:zhumingyu /share/</code></pre>



<h4 id="4-3-4-在服务端上给-samba-服务共享目录设置-selinux-标签">4.3.4 在服务端上给 Samba 服务共享目录设置 SELinux 标签</h4>



<p>（只在服务端上执行以下步骤）</p>



<pre class="wp-block-code"><code># semanage fcontext -a -t samba_share_t '/share(/.*)?'</code></pre>



<h4 id="4-3-5-在服务端上让-samba-服务共享目录上的-selinux-标签立刻生效">4.3.5 在服务端上让 Samba 服务共享目录上的 SELinux 标签立刻生效</h4>



<p>（只在服务端上执行以下步骤）</p>



<pre class="wp-block-code"><code># restorecon -RFvv /share/</code></pre>



<h4 id="步骤五-启动-samba-服务并设置为开机自动启动">步骤五：启动 Samba 服务并设置为开机自动启动</h4>



<p>（只在服务端上执行以下步骤）</p>



<pre class="wp-block-code"><code># systemctl enable --now smb</code></pre>



<h4 id="步骤六-客户端使用服务端-samba-服务6-1-在客户端上安装-samba-客户端软件">步骤六：客户端使用服务端 Samba 服务<br>6.1 在客户端上安装 Samba 客户端软件</h4>



<p>（只在客户端上执行以下步骤）</p>



<pre class="wp-block-code"><code># yum -y install samba-client cifs-utils</code></pre>



<h4 id="6-2-在客户端上测试服务端的-samba-服务">6.2 在客户端上测试服务端的 Samba 服务</h4>



<p>（只在客户端上执行以下步骤）</p>



<pre class="wp-block-code"><code># smbclient --user=zhumingyu -L //192.168.101.41</code></pre>



<p>或者：</p>



<pre class="wp-block-code"><code># smbclient //192.168.101.41/sharetest -U zhumingyu
smb: \&gt; ls
smb: \&gt; exit</code></pre>



<h4 id="6-3-在客户端上挂载服务端的-samba-目录6-3-1-手动挂载的方法">6.3 在客户端上挂载服务端的 Samba 目录<br>6.3.1 手动挂载的方法</h4>



<p>（只在客户端上执行以下步骤）</p>



<pre class="wp-block-code"><code># mount -t cifs -o username=zhumingyu,password=1,sec=ntlmssp //192.168.101.41/sharetest /tmp</code></pre>



<h4 id="6-3-2-自动挂载的方法">6.3.2 自动挂载的方法</h4>



<p>（只在客户端上执行以下步骤）</p>



<pre class="wp-block-code"><code># vim /etc/fstable</code></pre>



<p>添加以下内容：</p>



<pre class="wp-block-code"><code>......
# //192.168.101.41/sharetest /tmp cifs defaults,rw,username=zhumingyu,password=1 0 0</code></pre>
]]></content:encoded>
					
		
		
			</item>
		<item>
		<title>[命令] Linux 命令 mail （发送邮件）</title>
		<link>https://eternalcenter-2022-02.github.io/mail/</link>
		
		<dc:creator><![CDATA[Mingyu Zhu]]></dc:creator>
		<pubDate>Wed, 22 Jul 2020 03:02:52 +0000</pubDate>
				<category><![CDATA[Chinese (中文)]]></category>
		<category><![CDATA[Mail]]></category>
		<category><![CDATA[Other Services (其他服务)]]></category>
		<category><![CDATA[Services (服务)]]></category>
		<category><![CDATA[System (系统)]]></category>
		<category><![CDATA[System Operation (系统操作)]]></category>
		<category><![CDATA[System Operation & System Setting & System Software (系统操作 & 系统设置 & 系统软件)]]></category>
		<guid isPermaLink="false">https://eternalcenter-2022-02.github.io/?p=10220</guid>

					<description><![CDATA[内容一：mail 命令选项1.1 输入 mail 命令后的选项 1) h 或者 headers 显示处于激活状态的邮件开头2) f 或者 from 显示编号为 的邮件的标题2) t 或者 type 显示编号为 的邮件3) top 显示当前指针所指向的邮件头4) n 或者 next 显示下一条邮件信息5) e 编辑编号为 的邮件6) d 或者 delete 删除编号为 的邮件7) u 或者 undelete 取消删除编号为 的邮件8) s 或者 save 追加信息到编号为 的邮件信息到 目录中并标记和保存9) c 或者 copy 追加信息到编号为 的邮件信息到 目录中但不保存10) w 或者 write 追加信息到编号为 &#8230; <p class="link-more"><a href="https://eternalcenter-2022-02.github.io/mail/" class="more-link">Continue reading<span class="screen-reader-text"> "[命令] Linux 命令 mail （发送邮件）"</span></a></p>]]></description>
										<content:encoded><![CDATA[
<h4 id="内容一-mail-命令选项-1-1-输入-mail-命令后的选项">内容一：mail 命令选项<br>1.1 输入 mail 命令后的选项</h4>



<p>1) h 或者 headers 显示处于激活状态的邮件开头<br>2) f 或者 from 显示编号为 的邮件的标题<br>2) t 或者 type 显示编号为 的邮件<br>3) top 显示当前指针所指向的邮件头<br>4) n 或者 next 显示下一条邮件信息<br>5) e 编辑编号为 的邮件<br>6) d 或者 delete 删除编号为 的邮件<br>7) u 或者 undelete 取消删除编号为 的邮件<br>8) s 或者 save 追加信息到编号为 的邮件信息到 目录中并标记和保存<br>9) c 或者 copy 追加信息到编号为 的邮件信息到 目录中但不保存<br>10) w 或者 write 追加信息到编号为 的邮件信息到 文件中并保存附件<br>11) R 或者 Reply 回复编号为 的邮件的发件人<br>12) r 或者 reply 回复编号为 的邮件的发件人和所有收件人<br>13) m 或者 mail 回复编号为 的邮件，并回复多个联系人，多个收件人用空格分开 （需要 sendmail 软件支持此功能）<br>14) q 或者 quit 退出并保存新编辑的内容，q 会把邮件放在 ~/mbox 中，执行 pre 后就不取回<br>15) pre 将编号为 的邮件保留在 /usr/spool/mail，q 会把邮件放在 ~/mbox 中，执行 pre 后就不取回<br>16) x 或者 xit 只退出不保存新编辑的内容<br>17) file 显示邮件总数和在系统中所在的目录等信息<br>18) ! 执行 shell 的命令，例如 !ls<br>19) list 列出所有可用的命令</p>



<h4 id="1-2-在-mail-命令后添加选项">1.2 在 mail 命令后添加选项</h4>



<p>1) -s 设置邮件的标题<br>2) -a 添加附件<br>3) -c …… 给多个邮件地址抄送邮件，不同邮件的邮件地址用空格隔开<br>4) -b …… 给多个邮件地址悄悄抄送邮件，不同邮件的邮件地址用空格隔开<br>5) -e 检查系统邮件中是否有邮件<br>6) -f 显示邮箱里的邮件<br>7) -f + 显示 folder 目录邮箱中的邮件<br>8) -i 忽略 tty 信号中断<br>9) -v 显示发送邮件过程的详细信息<br>10) -h 显示帮助信息<br>11) uuencode 发送文件，第一个附件是要发送的附件，第二个是设置的名称 （此选项需要安装 sharutils 软件）</p>



<h4 id="内容二-mail-命令的使用案例-2-1-交互式发送邮件">内容二：mail 命令的使用案例<br>2.1 交互式发送邮件</h4>



<pre class="wp-block-code"><code># mail -s test mingyu.zhu@eternalcenter.com</code></pre>



<p>（补充：这里以向邮箱 mingyu.zhu@eternalcenter.com 发送标题为 test 的邮件为例）</p>



<p>（注意：键入此命令后进入交互式编辑内容的模式，内容编辑完了以后可以按下 “Ctrl” 之后再按下 “D” 退出）</p>



<h4 id="2-2-非交互式发送邮件">2.2 非交互式发送邮件</h4>



<pre class="wp-block-code"><code># echo 'test content' | mail -s 'test header' mingyu.zhu@eternalcenter.com</code></pre>



<p>（补充：这里以向 mingyu.zhu@eternalcenter.com 邮箱发送标题为 test header 内容为 test content 的邮件为例）</p>



<h4 id="2-3-非交互式将文件里的内容作为内容发送邮件">2.3 非交互式将文件里的内容作为内容发送邮件</h4>



<pre class="wp-block-code"><code># mail -s “test.txt” mingyu.zhu@eternalcenter.com &lt; test.txt</code></pre>



<p>（补充：这里以向 mingyu.zhu@eternalcenter.com 邮箱发送标题为 test header 将 test.txt 文件里的内容作为邮件内容的邮件为例）</p>



<h4 id="2-4-非交互式将文件作为附件发送邮件">2.4 非交互式将文件作为附件发送邮件</h4>



<pre class="wp-block-code"><code># uuencode /tmp/test.txt test.txt | mail -s 'test' mingyu.zhu@eternalcenter.com</code></pre>



<p>（补充：这里以向 mingyu.zhu@eternalcenter.com 邮箱发送标题为 test 将 test.txt 文件作为名为 test.txt 的附件的邮件为例）</p>



<h4 id="2-5-非交互式打包将文件作为附件发送邮件">2.5 非交互式打包将文件作为附件发送邮件</h4>



<pre class="wp-block-code"><code># tar -czf test.txt.tar /tmp/test.txt | uuencode test.txt.tar | mail -s 'test' mingyu.zhu@eternalcenter.com</code></pre>



<p>（补充：这里以向 mingyu.zhu@eternalcenter.com 邮箱发送标题为 test 将 test.txt.tar 文件作为名为 test.txt.tar 的附件的邮件为例）</p>



<h4 id="2-6-非交互式将给多个用户抄送邮件">2.6 非交互式将给多个用户抄送邮件</h4>



<pre class="wp-block-code"><code># mail -s “test.txt” -c "mingyu.zhu2@eternalcenter.com mingyu.zhu1@eternalcenter.com" mingyu.zhu@eternalcenter.com &lt; test.txt</code></pre>



<p>（补充：这里以向 mingyu.zhu@eternalcenter.com 邮箱发送标题为 test header 将 test.txt 文件里的内容作为邮件内容的邮件，并抄送给 mingyu.zhu2@eternalcenter.com 邮箱和 mingyu.zhu1@eternalcenter.com 邮箱为例）</p>
]]></content:encoded>
					
		
		
			</item>
		<item>
		<title>[内容] Postfix 数据的加密 （通过 TLS 实现）</title>
		<link>https://eternalcenter-2022-02.github.io/postfix-tls/</link>
		
		<dc:creator><![CDATA[Mingyu Zhu]]></dc:creator>
		<pubDate>Wed, 22 Jul 2020 02:56:38 +0000</pubDate>
				<category><![CDATA[Chinese (中文)]]></category>
		<category><![CDATA[Mail]]></category>
		<category><![CDATA[Other Services (其他服务)]]></category>
		<category><![CDATA[Services (服务)]]></category>
		<category><![CDATA[System (系统)]]></category>
		<category><![CDATA[System Network & System Security & System Log (系统网络 & 系统安全 & 系统日志)]]></category>
		<category><![CDATA[System Port Security (系统端口安全)]]></category>
		<category><![CDATA[System Security (系统安全)]]></category>
		<guid isPermaLink="false">https://eternalcenter-2022-02.github.io/?p=10215</guid>

					<description><![CDATA[内容一：Postfix 不使用 TLS 加密数据传输的后果 1) 收发的邮件数据会被他人截取2) 给 Gmail 等电子邮箱发送邮件时，会提示类似 “ *** 未对此邮件进行加密” 的信息 内容二：给 Postfix 设置 TLS 加密数据传输的方法2.1 给 Postfix 的配置文件设置 TLS 机密数据传输的参数 添加以下内容： （补充：smtpd_tls_security_level 代表接收邮件的 TLS 安全等级smtp_tls_security_level 代表发送邮件的 TLS 安全等级TLS 的常用安全等级有 none、may 和 encrypt ：1) none 表示禁止使用 TLS 加密2) may 表示可以接收不使用 TLS 加密的邮件，但是会提出支持 TLS 加密的通告。发送邮件时优先发送支持 TLS 加密的邮件3) encrypt 表示强制使用 TLS 加密） 2.2 重启 Postfix &#8230; <p class="link-more"><a href="https://eternalcenter-2022-02.github.io/postfix-tls/" class="more-link">Continue reading<span class="screen-reader-text"> "[内容] Postfix 数据的加密 （通过 TLS 实现）"</span></a></p>]]></description>
										<content:encoded><![CDATA[
<h4>内容一：Postfix 不使用 TLS 加密数据传输的后果</h4>



<p>1) 收发的邮件数据会被他人截取<br>2) 给 Gmail 等电子邮箱发送邮件时，会提示类似 “ *** 未对此邮件进行加密” 的信息</p>



<h4>内容二：给 Postfix 设置 TLS 加密数据传输的方法<br>2.1 给 Postfix 的配置文件设置 TLS 机密数据传输的参数</h4>



<pre class="wp-block-code"><code># vim /etc/postfix/main.cf</code></pre>



<p>添加以下内容：</p>



<pre class="wp-block-code"><code>......
smtpd_tls_security_level = may
smtp_tls_security_level = may
......</code></pre>



<p>（<br>补充：<br>smtpd_tls_security_level 代表接收邮件的 TLS 安全等级<br>smtp_tls_security_level 代表发送邮件的 TLS 安全等级<br>TLS 的常用安全等级有 none、may 和 encrypt ：<br>1) none 表示禁止使用 TLS 加密<br>2) may 表示可以接收不使用 TLS 加密的邮件，但是会提出支持 TLS 加密的通告。发送邮件时优先发送支持 TLS 加密的邮件<br>3) encrypt 表示强制使用 TLS 加密<br>）</p>



<h4>2.2 重启 Postfix 服务</h4>



<pre class="wp-block-code"><code># systemctl restart postfix</code></pre>
]]></content:encoded>
					
		
		
			</item>
		<item>
		<title>[内容] DNS 客户端的设置 （Linux 版）</title>
		<link>https://eternalcenter-2022-02.github.io/dns-client/</link>
		
		<dc:creator><![CDATA[Mingyu Zhu]]></dc:creator>
		<pubDate>Thu, 16 Jul 2020 12:14:07 +0000</pubDate>
				<category><![CDATA[Chinese (中文)]]></category>
		<category><![CDATA[DNS]]></category>
		<category><![CDATA[Other Services (其他服务)]]></category>
		<category><![CDATA[Services (服务)]]></category>
		<category><![CDATA[System (系统)]]></category>
		<category><![CDATA[System Network (系统网络)]]></category>
		<category><![CDATA[System Network & System Security & System Log (系统网络 & 系统安全 & 系统日志)]]></category>
		<guid isPermaLink="false">https://eternalcenter-2022-02.github.io/?p=10066</guid>

					<description><![CDATA[内容一：设置 DNS 客户端1.1 直接在本地指定域名1.1.1 直接在本地指定域名的方法 添加以下内容： （注意：/etc/hosts 里记录的 DNS 优先级要比 /etc/resolv.conf 里的高） 1.1.2 直接在本地指定域名的案例 添加以下内容： （补充：这里以将 192.154.240.64 解析为 eternalcenter.com 为例） （注意：/etc/hosts 里记录的 DNS 优先级要比 /etc/resolv.conf 里的高） 1.2 使用远程的 DNS 服务器解析域名1.2.1 使用远程的 DNS 服务器解析域名1.2.1.1 使用远程的 DNS 服务器解析域名的方法1.2.1.1.1 直接修改 /etc/resolv.conf 文件 添加以下内容： （注意：/etc/hosts 里记录的 DNS 优先级要比 /etc/resolv.conf 里的高） 1.2.1.1.2 使用 nmcli 命令1.2.1.1.2.1 使用 nmcli 命令配置一个 DNS 服务器的 &#8230; <p class="link-more"><a href="https://eternalcenter-2022-02.github.io/dns-client/" class="more-link">Continue reading<span class="screen-reader-text"> "[内容] DNS 客户端的设置 （Linux 版）"</span></a></p>]]></description>
										<content:encoded><![CDATA[
<h4 id="内容一-设置-dns-客户端1-1-直接在本地指定域名1-1-1-直接在本地指定域名的方法">内容一：设置 DNS 客户端<br>1.1 直接在本地指定域名<br>1.1.1 直接在本地指定域名的方法</h4>



<pre class="wp-block-code"><code># vim /etc/hosts</code></pre>



<p>添加以下内容：</p>



<pre class="wp-block-code"><code>......
&lt;IP address&gt; &lt;domain name&gt;</code></pre>



<p>（注意：/etc/hosts 里记录的 DNS 优先级要比 /etc/resolv.conf 里的高）</p>



<h4 id="1-1-2-直接在本地指定域名的案例">1.1.2 直接在本地指定域名的案例</h4>



<pre class="wp-block-code"><code># vim /etc/hosts</code></pre>



<p>添加以下内容：</p>



<pre class="wp-block-code"><code>......
192.154.240.64 eternalcenter.com</code></pre>



<p>（补充：这里以将 192.154.240.64 解析为 eternalcenter.com 为例）</p>



<p>（注意：/etc/hosts 里记录的 DNS 优先级要比 /etc/resolv.conf 里的高）</p>



<h4 id="1-2-使用远程的-dns-服务器解析域名1-2-1-使用远程的-dns-服务器解析域名1-2-1-1-使用远程的-dns-服务器解析域名的方法1-2-1-1-1-直接修改-etc-resolv-conf-文件">1.2 使用远程的 DNS 服务器解析域名<br>1.2.1 使用远程的 DNS 服务器解析域名<br>1.2.1.1 使用远程的 DNS 服务器解析域名的方法<br>1.2.1.1.1 直接修改 /etc/resolv.conf 文件</h4>



<pre class="wp-block-code"><code># vim /etc/resolv.conf</code></pre>



<p>添加以下内容：</p>



<pre class="wp-block-code"><code>......
nameserver &lt;IP address of DNS server&gt;</code></pre>



<p>（注意：/etc/hosts 里记录的 DNS 优先级要比 /etc/resolv.conf 里的高）</p>



<h4 id="1-2-1-1-2-使用-nmcli-命令1-2-1-1-2-1-使用-nmcli-命令配置一个-dns-服务器的-ip-地址">1.2.1.1.2 使用 nmcli 命令<br>1.2.1.1.2.1 使用 nmcli 命令配置一个 DNS 服务器的 IP 地址</h4>



<pre class="wp-block-code"><code># nmcli connection modify &lt;network card name&gt; ipv4.dns &lt;IP address of DNS server&gt;</code></pre>



<p>（补充：不将 /etc/NetworkManager/NetworkManager.conf 里的 [main] dns=none 参数修改为 none 的话，此参数会覆盖 /etc/resolv.conf 里的设置）</p>



<p>（<br>注意：<br>1) 此方法只对 CentOS8&amp;RHEL8 适用<br>2) /etc/hosts 里记录的 DNS 优先级要比使用 nmcli 命令的高<br>）</p>



<h4 id="1-2-1-1-2-2-使用-nmcli-命令配置多个-dns-服务器的-ip-地址">1.2.1.1.2.2 使用 nmcli 命令配置多个 DNS 服务器的 IP 地址</h4>



<pre class="wp-block-code"><code># nmcli connection modify &lt;network card name&gt; ipv4.dns "&lt;first IP address of DNS server&gt;,&lt;second IP address of DNS server&gt;,&lt;third IP address of DNS server&gt;......"</code></pre>



<p>（补充：不将 /etc/NetworkManager/NetworkManager.conf 里的 [main] dns=none 参数修改为 none 的话，此参数会覆盖 /etc/resolv.conf 里的设置）</p>



<p>（<br>注意：<br>1) 此方法只对 CentOS8&amp;RHEL8 适用<br>2) /etc/hosts 里记录的 DNS 优先级要比使用 nmcli 命令的高<br>）</p>



<h4 id="1-2-1-2-使用远程的-dns-服务器解析域名的案例1-2-1-2-1-直接修改-etc-resolv-conf-文件">1.2.1.2 使用远程的 DNS 服务器解析域名的案例<br>1.2.1.2.1 直接修改 /etc/resolv.conf 文件</h4>



<pre class="wp-block-code"><code># vim /etc/resolv.conf</code></pre>



<p>添加以下内容：</p>



<pre class="wp-block-code"><code>......
nameserver 8.8.8.8</code></pre>



<p>（补充：这里以使用 8.8.8.8 DNS 服务器为例）</p>



<p>（注意：/etc/hosts 里记录的 DNS 优先级要比 /etc/resolv.conf 里的高）</p>



<h4 id="1-2-1-2-2-使用-nmcli-命令">1.2.1.2.2 使用 nmcli 命令</h4>



<pre class="wp-block-code"><code># nmcli connection modify eth0 ipv4.dns 8.8.8.8</code></pre>



<p>（<br>补充：<br>1) 这里以给 eth0 网卡添加 8.8.8.8 DNS 服务器为例<br>2) 不将 /etc/NetworkManager/NetworkManager.conf 里的 [main] dns=none 参数修改为 none 的话，此参数会覆盖 /etc/resolv.conf 里的设置<br>）</p>



<p>（注意：/etc/hosts 里记录的 DNS 优先级要比使用 nmcli 命令的高）</p>



<h4 id="1-2-2-显示正在使用远程的-dns-服务器解析的域名">1.2.2 显示正在使用远程的 DNS 服务器解析的域名</h4>



<pre class="wp-block-code"><code># nmcli connection show | grep -i ipv4.dns</code></pre>



<h4 id="内容二-检查-dns-域名解析2-1-使用-ping-命令解析域名2-1-1-使用-ping-命令解析域名的格式">内容二：检查 DNS 域名解析<br>2.1 使用 ping 命令解析域名<br>2.1.1 使用 ping 命令解析域名的格式</h4>



<pre class="wp-block-code"><code># ping &lt;domain name&gt;</code></pre>



<h4 id="2-1-2-使用-ping-命令解析域名的案例">2.1.2 使用 ping 命令解析域名的案例</h4>



<pre class="wp-block-code"><code># ping eternalcenter.com
PING eternalcenter.com (192.154.240.64) 56(84) bytes of data.
64 bytes from v144-48-142.ap-east.sugarhosts.net (192.154.240.64): icmp_seq=1 ttl=50 time=144 ms
64 bytes from v144-48-142.ap-east.sugarhosts.net (192.154.240.64): icmp_seq=3 ttl=50 time=70.8 ms
64 bytes from v144-48-142.ap-east.sugarhosts.net (192.154.240.64): icmp_seq=4 ttl=50 time=81.3 ms
64 bytes from v144-48-142.ap-east.sugarhosts.net (192.154.240.64): icmp_seq=5 ttl=50 time=103 ms
......</code></pre>



<h4 id="2-2-使用-host-命令解析域名2-2-1-使用-host-命令解析域名的格式">2.2 使用 host 命令解析域名<br>2.2.1 使用 host 命令解析域名的格式</h4>



<pre class="wp-block-code"><code># host &lt;domain name&gt;</code></pre>



<h4 id="2-2-2-使用-host-命令解析域名的案例">2.2.2 使用 host 命令解析域名的案例</h4>



<pre class="wp-block-code"><code># host eternalcenter.com
eternalcenter.com has address 192.154.240.64</code></pre>



<p>（补充：这里以解析 etenalcenter.com 域名为例）</p>



<h4 id="2-3-使用-nslookup-命令解析域名2-3-1-使用-nslookup-命令解析域名的格式">2.3 使用 nslookup 命令解析域名<br>2.3.1 使用 nslookup 命令解析域名的格式</h4>



<pre class="wp-block-code"><code># nslookup &lt;domain name&gt;</code></pre>



<h4 id="2-3-2-使用-nslookup-命令解析域名的案例">2.3.2 使用 nslookup 命令解析域名的案例</h4>



<pre class="wp-block-code"><code># nslookup eternalcenter.com
Server:		8.8.8.8
Address:	8.8.8.8#53

Non-authoritative answer:
Name:	eternalcenter.com
Address: 192.154.240.64</code></pre>



<p>（补充：这里以解析 etenalcenter.com 域名为例）</p>
]]></content:encoded>
					
		
		
			</item>
		<item>
		<title>[实验] Chrony 客户端的设置 （时间同步）</title>
		<link>https://eternalcenter-2022-02.github.io/chrony-client/</link>
		
		<dc:creator><![CDATA[Mingyu Zhu]]></dc:creator>
		<pubDate>Fri, 12 Jun 2020 14:07:06 +0000</pubDate>
				<category><![CDATA[Chinese (中文)]]></category>
		<category><![CDATA[Chrony]]></category>
		<category><![CDATA[Other Services (其他服务)]]></category>
		<category><![CDATA[Services (服务)]]></category>
		<guid isPermaLink="false">https://eternalcenter-2022-02.github.io/?p=9756</guid>

					<description><![CDATA[注意：从 CentOS 7.2&#38;RHEL 7.0 开始实现时间同步的程序默认从 NTP 换成了 Chrony 。 NTP 也可以继续使用，但是需要单独安装 NTP 的安装包 步骤目录： 步骤一：系统环境要求步骤二：确保 Chrony 已经安装步骤三：确保系统会使用 Chrony 或 NTP 的时间同步步骤四：修改配置文件步骤五：重启客户端的 Chrony 服务步骤六：显示客户端时间同步的状态 具体的操作步骤： 步骤一：系统环境要求 1) 服务器的系统是 CentOS 8 版本2) 服务器系统配置好可用的软件源 步骤二：确保 Chrony 已经安装 步骤三：确保系统会使用 Chrony 或 NTP 的时间同步 步骤四：修改配置文件 将部分内容修改如下： （说明：在配置文件的开头添加要进行时间同步的服务器） 步骤五：重启客户端的 Chrony 服务 步骤六：显示客户端时间同步的状态 （补充：当出现 ^* 时则代表时间同步成功） 或者：]]></description>
										<content:encoded><![CDATA[
<p>注意：从 CentOS 7.2&amp;RHEL 7.0 开始实现时间同步的程序默认从 NTP 换成了 Chrony 。 NTP 也可以继续使用，但是需要单独安装 NTP 的安装包</p>



<h2 id="步骤目录">步骤目录：</h2>



<h4 id="步骤一-系统环境要求步骤二-确保-chrony-已经安装步骤三-确保系统会使用-chrony-或-ntp-的时间同步步骤四-修改配置文件步骤五-重启客户端的-chrony-服务步骤六-显示客户端时间同步的状态">步骤一：系统环境要求<br>步骤二：确保 Chrony 已经安装<br>步骤三：确保系统会使用 Chrony 或 NTP 的时间同步<br>步骤四：修改配置文件<br>步骤五：重启客户端的 Chrony 服务<br>步骤六：显示客户端时间同步的状态</h4>



<h2 id="具体的操作步骤">具体的操作步骤：</h2>



<h4 id="步骤一-系统环境要求">步骤一：系统环境要求</h4>



<p>1) 服务器的系统是 CentOS 8 版本<br>2) 服务器系统配置好可用的软件源</p>



<h4 id="步骤二-确保-chrony-已经安装">步骤二：确保 Chrony 已经安装</h4>



<pre class="wp-block-code"><code>
# yum -y install chrony</code></pre>



<h4 id="步骤三-确保系统会使用-chrony-或-ntp-的时间同步">步骤三：确保系统会使用 Chrony 或 NTP 的时间同步</h4>



<pre class="wp-block-code"><code># timedatectl set-ntp true
# timedatectl
               Local time: Fri 2020-06-12 09:52:30 EDT
           Universal time: Fri 2020-06-12 13:52:30 UTC
                 RTC time: Fri 2020-06-12 13:51:52
                Time zone: America/New_York (EDT, -0400)
System clock synchronized: yes
              NTP service: active
          RTC in local TZ: no</code></pre>



<h4 id="步骤四-修改配置文件">步骤四：修改配置文件</h4>



<pre class="wp-block-code"><code># vim /etc/chrony.conf</code></pre>



<p>将部分内容修改如下：</p>



<pre class="wp-block-code"><code>......
pool 2.centos.pool.ntp.org iburst</code></pre>



<p>（说明：在配置文件的开头添加要进行时间同步的服务器）</p>



<h4 id="步骤五-重启客户端的-chrony-服务">步骤五：重启客户端的 Chrony 服务</h4>



<pre class="wp-block-code"><code># systemctl restart chronyd
# systemctl status chronyd</code></pre>



<h4 id="步骤六-显示客户端时间同步的状态">步骤六：显示客户端时间同步的状态</h4>



<pre class="wp-block-code"><code># chronyc sources -v
210 Number of sources = 4

  .-- Source mode  '^' = server, '=' = peer, '#' = local clock.
 / .- Source state '*' = current synced, '+' = combined , '-' = not combined,
| /   '?' = unreachable, 'x' = time may be in error, '~' = time too variable.
||                                                 .- xxxx &#91; yyyy ] +/- zzzz
||      Reachability register (octal) -.           |  xxxx = adjusted offset,
||      Log2(Polling interval) --.      |          |  yyyy = measured offset,
||                                \     |          |  zzzz = estimated error.
||                                 |    |           \
MS Name/IP address         Stratum Poll Reach LastRx Last sample               
===============================================================================
^* time.rdg.uk.as44574.net       3   8   373   153    +73ms&#91;  +68ms] +/-  233ms</code></pre>



<p>（补充：当出现 ^* 时则代表时间同步成功）</p>



<p>或者：</p>



<pre class="wp-block-code"><code># chronyc tracking</code></pre>
]]></content:encoded>
					
		
		
			</item>
		<item>
		<title>[实验] VNC 远程桌面服务的搭建</title>
		<link>https://eternalcenter-2022-02.github.io/vnc-build/</link>
		
		<dc:creator><![CDATA[Mingyu Zhu]]></dc:creator>
		<pubDate>Tue, 21 Jan 2020 11:35:17 +0000</pubDate>
				<category><![CDATA[Chinese (中文)]]></category>
		<category><![CDATA[Other Services (其他服务)]]></category>
		<category><![CDATA[Services (服务)]]></category>
		<category><![CDATA[System (系统)]]></category>
		<category><![CDATA[VNC]]></category>
		<category><![CDATA[纪念 Anniversary]]></category>
		<guid isPermaLink="false">https://eternalcenter-2022-02.github.io/?p=8052</guid>

					<description><![CDATA[纪念：站主于 2020 年 1 月完成了此开源实验，并将过程中的所有命令经过整理和注释以后，形成以下教程 软件准备： 在 RealVNC 官网上下载使用 VNC 服务所需软件 VNC View： https://www.realvnc.com/en/ 正文： 步骤目录： 步骤一：规划拓扑1.1 服务器列表1.2 服务器列表简介 步骤二：系统环境要求 步骤三：服务端安装 VNC 服务3.1 服务端 VNC 环境准备3.1.1 在服务端上安装桌面3.1.2 在服务端上创建用于使用 VNC 的用户3.1.2.1 创建用户3.1.2.2 修改用户密码3.2 服务端安装 VNC 服务 步骤四：配置 VNC 服务4.1 创建 VNC 服务进程文件4.2 编辑 VNC 服务进程文件 步骤五：开机自启 VNC 服务5.1 刷新所有服务进程文件5.2 开机自启 VNC 服务 步骤六：启动 VNC 服务6.1 切换到使用 &#8230; <p class="link-more"><a href="https://eternalcenter-2022-02.github.io/vnc-build/" class="more-link">Continue reading<span class="screen-reader-text"> "[实验] VNC 远程桌面服务的搭建"</span></a></p>]]></description>
										<content:encoded><![CDATA[
<p class="has-vivid-red-color has-text-color has-medium-font-size"><strong><strong><strong>纪念：站主于 2020 年 1 月完成了此开源实验，并将过程中的所有命令经过整理和注释以后，形成以下教程</strong></strong></strong></p>



<h2 id="软件准备">软件准备：</h2>



<p>在 RealVNC 官网上下载使用 VNC 服务所需软件 VNC View：</p>



<p class="has-text-align-center"><a href="https://www.realvnc.com/en/" target="_blank" rel="noreferrer noopener">https://www.realvnc.com/en/</a></p>



<div style="height:100px" aria-hidden="true" class="wp-block-spacer"></div>



<h2 id="正文">正文：</h2>



<h2 id="步骤目录">步骤目录：</h2>



<h4 id="步骤一-规划拓扑1-1-服务器列表1-2-服务器列表简介">步骤一：规划拓扑<br>1.1 服务器列表<br>1.2 服务器列表简介</h4>



<h4 id="步骤二-系统环境要求">步骤二：系统环境要求</h4>



<h4 id="步骤三-服务端安装-vnc-服务3-1-服务端-vnc-环境准备3-1-1-在服务端上安装桌面3-1-2-在服务端上创建用于使用-vnc-的用户3-1-2-1-创建用户3-1-2-2-修改用户密码3-2-服务端安装-vnc-服务">步骤三：服务端安装 VNC 服务<br>3.1 服务端 VNC 环境准备<br>3.1.1 在服务端上安装桌面<br>3.1.2 在服务端上创建用于使用 VNC 的用户<br>3.1.2.1 创建用户<br>3.1.2.2 修改用户密码<br>3.2 服务端安装 VNC 服务</h4>



<h4 id="步骤四-配置-vnc-服务4-1-创建-vnc-服务进程文件4-2-编辑-vnc-服务进程文件">步骤四：配置 VNC 服务<br>4.1 创建 VNC 服务进程文件<br>4.2 编辑 VNC 服务进程文件</h4>



<h4 id="步骤五-开机自启-vnc-服务5-1-刷新所有服务进程文件5-2-开机自启-vnc-服务">步骤五：开机自启 VNC 服务<br>5.1 刷新所有服务进程文件<br>5.2 开机自启 VNC 服务</h4>



<h4 id="步骤六-启动-vnc-服务6-1-切换到使用-vnc-的用户6-2-开启-vnc-服务6-3-补充-修改-vnc-登陆密码的方法">步骤六：启动 VNC 服务<br>6.1 切换到使用 VNC 的用户<br>6.2 开启 VNC 服务<br>6.3 补充：修改 VNC 登陆密码的方法</h4>



<h4 id="步骤七-查看-vnc-服务是否启动成功">步骤七：确认 VNC 服务是否启动成功</h4>



<h4 id="步骤八-客户端使用-vnc-服务8-1-客户端使用-vnc-服务的前期工作8-1-1-在客户端上安装桌面8-1-2-客户端安装-vnc-服务的客户端8-1-3-客户端启动桌面8-2-客户端使用-vnc-服务8-2-1-客户端启动-vnc-服务的客户端8-2-2-连接服务端的-vnc-ip-地址和端口号8-2-3-输入服务端-vnc-用户的-vnc-密码8-2-4-vnc-服务成功">步骤八：客户端使用 VNC 服务<br>8.1 客户端使用 VNC 服务的前期工作<br>8.1.1 在客户端上安装桌面<br>8.1.2 客户端安装 VNC 服务的客户端<br>8.1.3 客户端启动桌面<br>8.2 客户端使用 VNC 服务<br>8.2.1 客户端启动 VNC 服务的客户端<br>8.2.2 连接服务端的 VNC IP 地址和端口号<br>8.2.3 输入服务端 VNC 用户的 VNC 密码<br>8.2.4 VNC 服务成功</h4>



<h2 id="具体的操作步骤">具体的操作步骤：</h2>



<h4 id="步骤一-规划拓扑1-1-服务器列表">步骤一：规划拓扑<br>1.1 服务器列表</h4>



<p>服务端 192.168.100.10<br>客户端 192.168.100.11</p>



<h4 id="1-2-服务器列表简介">1.2 服务器列表简介</h4>



<p>1) 服务器提供 VNC 服务让其他设备可以远程自己的桌面<br>2) 客户端通过 VNC 服务远程服务器的桌面</p>



<h4 id="步骤二-系统环境要求">步骤二：系统环境要求</h4>



<p>1) 所有服务器的系统都需要是 CentOS 7 版本<br>2) 所有服务器都要关闭防火墙<br>3) 所有服务器都要关闭 SELinux<br>4) 所有服务器系统都要配置好可用的软件源<br>5) 需要按照拓扑图给对应的服务器配置好 IP 地址和主机名<br>6) 所有服务器都要可以相互 ping 通自己和对方的 IP 地址和主机名</p>



<h4 id="步骤三-服务端安装-vnc-服务3-1-服务端-vnc-环境准备3-1-1-在服务端上安装桌面">步骤三：服务端安装 VNC 服务<br>3.1 服务端 VNC 环境准备<br>3.1.1 在服务端上安装桌面</h4>



<p>（只在服务端上执行以下步骤）</p>



<pre class="wp-block-code"><code># yum -y groupinstall "Server with GUI"
# yum -y groupinstall "GNOME Desktop"</code></pre>



<h4 id="3-1-2-在服务端上创建用于使用-vnc-的用户3-1-2-1-创建用户">3.1.2 在服务端上创建用于使用 VNC 的用户<br>3.1.2.1 创建用户</h4>



<p>（只在服务端上执行以下步骤）</p>



<pre class="wp-block-code"><code># useradd zhumingyu</code></pre>



<h4 id="3-1-2-2-修改用户密码">3.1.2.2 修改用户密码</h4>



<p>（只在服务端上执行以下步骤）</p>



<pre class="wp-block-code"><code># passwd zhumingyu</code></pre>



<h4 id="3-2-服务端安装-vnc-服务">3.2 服务端安装 VNC 服务</h4>



<p>（只在服务端上执行以下步骤）</p>



<pre class="wp-block-code"><code># yum -y install tigervnc tigervnc-server</code></pre>



<h4 id="步骤四-配置-vnc-服务4-1-创建-vnc-服务进程文件">步骤四：配置 VNC 服务<br>4.1 创建 VNC 服务进程文件</h4>



<p>（只在服务端上执行以下步骤）</p>



<pre class="wp-block-code"><code># cp /lib/systemd/system/vncserver\@.service /lib/systemd/system/vncserver\@:1.service</code></pre>



<h4 id="4-2-编辑-vnc-服务进程文件">4.2 编辑 VNC 服务进程文件</h4>



<p>（只在服务端上执行以下步骤）</p>



<pre class="wp-block-code"><code># vi /lib/systemd/system/vncserver\@:1.service</code></pre>



<p>将其中的：</p>



<pre class="wp-block-code"><code>......
&#91;Unit]
Description=Remote desktop service (VNC)
After=syslog.target network.target

&#91;Service]
Type=forking

# Clean any existing files in /tmp/.X11-unix environment
ExecStartPre=/bin/sh -c '/usr/bin/vncserver -kill %i &gt; /dev/null 2&gt;&amp;1 || :'
ExecStart=/usr/sbin/runuser -l &lt;USER&gt; -c "/usr/bin/vncserver %i"
PIDFile=/home/&lt;USER&gt;/.vnc/%H%i.pid
ExecStop=/bin/sh -c '/usr/bin/vncserver -kill %i &gt; /dev/null 2&gt;&amp;1 || :'

&#91;Install]
WantedBy=multi-user.target</code></pre>



<p>修改为：</p>



<pre class="wp-block-code"><code>......
&#91;Unit]
Description=Remote desktop service (VNC)
After=syslog.target network.target

&#91;Service]
Type=forking

# Clean any existing files in /tmp/.X11-unix environment
ExecStartPre=/bin/sh -c '/usr/bin/vncserver -kill %i &gt; /dev/null 2&gt;&amp;1 || :'
ExecStart=/usr/sbin/runuser -l zhumingyu -c "/usr/bin/vncserver %i"
PIDFile=/home/zhumingyu/.vnc/%H%i.pid
ExecStop=/bin/sh -c '/usr/bin/vncserver -kill %i &gt; /dev/null 2&gt;&amp;1 || :'

&#91;Install]
WantedBy=multi-user.target</code></pre>



<h4 id="步骤五-开机自启-vnc-服务5-1-刷新所有服务进程文件">步骤五：开机自启 VNC 服务<br>5.1 刷新所有服务进程文件</h4>



<p>（只在服务端上执行以下步骤）</p>



<pre class="wp-block-code"><code># systemctl daemon-reload</code></pre>



<h4 id="5-2-开机自启-vnc-服务">5.2 开机自启 VNC 服务</h4>



<p>（只在服务端上执行以下步骤）</p>



<pre class="wp-block-code"><code># systemctl enable vncserver@:1.service
Created symlink from /etc/systemd/system/multi-user.target.wants/vncserver@:1.service to /usr/lib/systemd/system/vncserver@:1.service.</code></pre>



<h4 id="步骤六-启动-vnc-服务6-1-切换到使用-vnc-的用户">步骤六：启动 VNC 服务<br>6.1 切换到使用 VNC 的用户</h4>



<p>（只在服务端上执行以下步骤）</p>



<pre class="wp-block-code"><code># su - zhumingyu</code></pre>



<h4 id="6-2-开启-vnc-服务">6.2 开启 VNC 服务</h4>



<p>（只在服务端上执行以下步骤）</p>



<pre class="wp-block-code"><code>$ vncserver :1

You will require a password to access your desktops.

Password:
Verify:
Would you like to enter a view-only password (y/n)? y
Password:
Verify:

New 'vnc:1 (zhumingyu)' desktop is vnc:1

Creating default startup script /home/zhumingyu/.vnc/xstartup
Creating default config /home/zhumingyu/.vnc/config
Starting applications specified in /home/zhumingyu/.vnc/xstartup
Log file is /home/zhumingyu/.vnc/vnc:1.log</code></pre>



<h4 id="6-3-补充-修改-vnc-登陆密码的方法">6.3 补充：修改 VNC 登陆密码的方法</h4>



<pre class="wp-block-code"><code># su - zhumingyu
$ vncpasswd</code></pre>



<h4 id="步骤七-查看-vnc-服务是否启动成功">步骤七：确认 VNC 服务是否启动成功</h4>



<p>（只在服务端上执行以下步骤）</p>



<pre class="wp-block-code"><code>$ ss -ntulap | grep 5901
tcp    LISTEN     0      5         *:5901                  *:*                   users:(("Xvnc",pid=1152,fd=9))
tcp    LISTEN     0      5      &#91;::]:5901               &#91;::]:*                   users:(("Xvnc",pid=1152,fd=10))</code></pre>



<h4 id="步骤八-客户端使用-vnc-服务8-1-客户端使用-vnc-服务的前期工作8-1-1-在客户端上安装桌面">步骤八：客户端使用 VNC 服务<br>8.1 客户端使用 VNC 服务的前期工作<br>8.1.1 在客户端上安装桌面</h4>



<p>（只在客户端上执行以下步骤）</p>



<pre class="wp-block-code"><code># yum -y groupinstall "Server with GUI"
# yum -y groupinstall "GNOME Desktop"</code></pre>



<h4 id="8-1-2-客户端安装-vnc-服务的客户端">8.1.2 客户端安装 VNC 服务的客户端</h4>



<p>（只在客户端上执行以下步骤）</p>



<pre class="wp-block-code"><code># yum -y localinstall VNC-Viewer-6.19.1115-Linux-x64.rpm</code></pre>



<p>（补充：这里以安装 VNC-Viewer-6.19.1115-Linux-x64.rpm 为例）</p>



<h4 id="8-1-3-客户端启动桌面">8.1.3 客户端启动桌面</h4>



<p>（只在客户端上执行以下步骤）</p>



<pre class="wp-block-code"><code># startx</code></pre>



<div class="wp-block-image"><figure class="aligncenter size-full"><img width="768" height="466" src="https://eternalcenter-2022-02.github.io/wp-content/uploads/2021/12/VNC-1.png" alt="" class="wp-image-19755" srcset="https://eternalcenter-2022-02.github.io/wp-content/uploads/2021/12/VNC-1.png 768w, https://eternalcenter-2022-02.github.io/wp-content/uploads/2021/12/VNC-1-300x182.png 300w" sizes="(max-width: 767px) 89vw, (max-width: 1000px) 54vw, (max-width: 1071px) 543px, 580px" /><figcaption>（图：1）</figcaption></figure></div>



<h4 id="8-2-客户端使用-vnc-服务8-2-1-客户端启动-vnc-服务的客户端">8.2 客户端使用 VNC 服务<br>8.2.1 客户端启动 VNC 服务的客户端</h4>



<p>（只在客户端上执行以下步骤）</p>



<div class="wp-block-image"><figure class="aligncenter size-full"><img loading="lazy" width="768" height="466" src="https://eternalcenter-2022-02.github.io/wp-content/uploads/2021/12/VNC-2.png" alt="" class="wp-image-19756" srcset="https://eternalcenter-2022-02.github.io/wp-content/uploads/2021/12/VNC-2.png 768w, https://eternalcenter-2022-02.github.io/wp-content/uploads/2021/12/VNC-2-300x182.png 300w" sizes="(max-width: 767px) 89vw, (max-width: 1000px) 54vw, (max-width: 1071px) 543px, 580px" /><figcaption>（图：2）</figcaption></figure></div>



<div class="wp-block-image"><figure class="aligncenter size-full"><img loading="lazy" width="768" height="466" src="https://eternalcenter-2022-02.github.io/wp-content/uploads/2021/12/VNC-3.png" alt="" class="wp-image-19757" srcset="https://eternalcenter-2022-02.github.io/wp-content/uploads/2021/12/VNC-3.png 768w, https://eternalcenter-2022-02.github.io/wp-content/uploads/2021/12/VNC-3-300x182.png 300w" sizes="(max-width: 767px) 89vw, (max-width: 1000px) 54vw, (max-width: 1071px) 543px, 580px" /><figcaption>（图：3）</figcaption></figure></div>



<div class="wp-block-image"><figure class="aligncenter size-full"><img loading="lazy" width="768" height="466" src="https://eternalcenter-2022-02.github.io/wp-content/uploads/2021/12/VNC-4.png" alt="" class="wp-image-19758" srcset="https://eternalcenter-2022-02.github.io/wp-content/uploads/2021/12/VNC-4.png 768w, https://eternalcenter-2022-02.github.io/wp-content/uploads/2021/12/VNC-4-300x182.png 300w" sizes="(max-width: 767px) 89vw, (max-width: 1000px) 54vw, (max-width: 1071px) 543px, 580px" /><figcaption>（图：4）</figcaption></figure></div>



<h4 id="8-2-2-连接服务端的-vnc-ip-地址和端口号">8.2.2 连接服务端的 VNC IP 地址和端口号</h4>



<p>（只在客户端上执行以下步骤）</p>



<div class="wp-block-image"><figure class="aligncenter size-full"><img loading="lazy" width="768" height="466" src="https://eternalcenter-2022-02.github.io/wp-content/uploads/2021/12/VNC-5.png" alt="" class="wp-image-19759" srcset="https://eternalcenter-2022-02.github.io/wp-content/uploads/2021/12/VNC-5.png 768w, https://eternalcenter-2022-02.github.io/wp-content/uploads/2021/12/VNC-5-300x182.png 300w" sizes="(max-width: 767px) 89vw, (max-width: 1000px) 54vw, (max-width: 1071px) 543px, 580px" /><figcaption>（图：5）</figcaption></figure></div>



<div class="wp-block-image"><figure class="aligncenter size-full"><img loading="lazy" width="768" height="466" src="https://eternalcenter-2022-02.github.io/wp-content/uploads/2021/12/VNC-6.png" alt="" class="wp-image-19760" srcset="https://eternalcenter-2022-02.github.io/wp-content/uploads/2021/12/VNC-6.png 768w, https://eternalcenter-2022-02.github.io/wp-content/uploads/2021/12/VNC-6-300x182.png 300w" sizes="(max-width: 767px) 89vw, (max-width: 1000px) 54vw, (max-width: 1071px) 543px, 580px" /><figcaption>（图：6）</figcaption></figure></div>



<h4 id="8-2-3-输入服务端-vnc-用户的-vnc-密码">8.2.3 输入服务端 VNC 用户的 VNC 密码</h4>



<p>（只在客户端上执行以下步骤）</p>



<div class="wp-block-image"><figure class="aligncenter size-full"><img loading="lazy" width="768" height="466" src="https://eternalcenter-2022-02.github.io/wp-content/uploads/2021/12/VNC-7.png" alt="" class="wp-image-19761" srcset="https://eternalcenter-2022-02.github.io/wp-content/uploads/2021/12/VNC-7.png 768w, https://eternalcenter-2022-02.github.io/wp-content/uploads/2021/12/VNC-7-300x182.png 300w" sizes="(max-width: 767px) 89vw, (max-width: 1000px) 54vw, (max-width: 1071px) 543px, 580px" /><figcaption>（图：7）</figcaption></figure></div>



<h4 id="8-2-4-vnc-服务成功">8.2.4 VNC 服务成功</h4>



<p>（只在客户端上执行以下步骤）</p>



<div class="wp-block-image"><figure class="aligncenter size-full"><img loading="lazy" width="768" height="466" src="https://eternalcenter-2022-02.github.io/wp-content/uploads/2021/12/VNC-8.png" alt="" class="wp-image-19762" srcset="https://eternalcenter-2022-02.github.io/wp-content/uploads/2021/12/VNC-8.png 768w, https://eternalcenter-2022-02.github.io/wp-content/uploads/2021/12/VNC-8-300x182.png 300w" sizes="(max-width: 767px) 89vw, (max-width: 1000px) 54vw, (max-width: 1071px) 543px, 580px" /><figcaption>（图：8）</figcaption></figure></div>
]]></content:encoded>
					
		
		
			</item>
		<item>
		<title>[工具] Shell 批量检测域名的 DNS 解析是否正确</title>
		<link>https://eternalcenter-2022-02.github.io/shell-dns-check/</link>
		
		<dc:creator><![CDATA[Mingyu Zhu]]></dc:creator>
		<pubDate>Sun, 11 Aug 2019 04:03:58 +0000</pubDate>
				<category><![CDATA[Chinese (中文)]]></category>
		<category><![CDATA[DNS]]></category>
		<category><![CDATA[Languages (语言)]]></category>
		<category><![CDATA[Other Services (其他服务)]]></category>
		<category><![CDATA[Services (服务)]]></category>
		<category><![CDATA[Shell]]></category>
		<category><![CDATA[Shell Monitor (监控)]]></category>
		<category><![CDATA[Shell Tool (工具)]]></category>
		<guid isPermaLink="false">https://eternalcenter-2022-02.github.io/?p=5112</guid>

					<description><![CDATA[介绍： 作者：朱明宇名称：批量检测域名的 DNS 解析是否正确作用：批量检测域名的 DNS 解析是否正确 使用方法：1. 在此脚本的分割线内写入相应的内容2. 给此脚本添加执行权限3. 执行此脚本 脚本分割线里的变量：1. main_domain=eternalcenter.com #此处填写网站的“主域名”，网站一般会有几个域名，其中“主域名”直接指向 ip 地址，其他的域名都指向主域名2. ip=192.154.240.64 #域名指向的 ip 地址3. nginx=1.16.0 #web 程序的对应版本的版本4. content1=&#8221;eteranlcenter&#8221; # 随即填写一个具有代表性的网站首页的内容5. content2=&#8221;Mingyu&#8221; # 随即填写一个具有代表性的网站首页的内容，但是要和前面的 content1 在同一行6. domain=&#8221;eternalcenter.com eternalcentre.com zhumingyu.com mingyuzhu.com eternalcenter.org eternalcentre.org&#8221; #需要检测的域名 脚本：]]></description>
										<content:encoded><![CDATA[
<h2>介绍：</h2>



<p>作者：朱明宇<br>名称：批量检测域名的 DNS 解析是否正确<br>作用：批量检测域名的 DNS 解析是否正确</p>



<p>使用方法：<br>1. 在此脚本的分割线内写入相应的内容<br>2. 给此脚本添加执行权限<br>3. 执行此脚本</p>



<p>脚本分割线里的变量：<br>1. main_domain=eternalcenter.com #此处填写网站的“主域名”，网站一般会有几个域名，其中“主域名”直接指向 ip 地址，其他的域名都指向主域名<br>2. ip=192.154.240.64 #域名指向的 ip 地址<br>3. nginx=1.16.0 #web 程序的对应版本的版本<br>4. content1=&#8221;eteranlcenter&#8221; # 随即填写一个具有代表性的网站首页的内容<br>5. content2=&#8221;Mingyu&#8221; # 随即填写一个具有代表性的网站首页的内容，但是要和前面的 content1 在同一行<br>6. domain=&#8221;eternalcenter.com eternalcentre.com zhumingyu.com mingyuzhu.com eternalcenter.org eternalcentre.org&#8221; #需要检测的域名</p>



<h2>脚本：</h2>



<pre class="wp-block-code"><code>#!/bin/bash

####################### Separator ########################

main_domain=eternalcenter.com
ip=144.48.142.148
nginx=1.16.0
content1="eternalcenter"
content2="Mingyu"
domain="eternalcenter.com eternalcentre.com zhumingyu.com mingyuzhu.com eternalcenter.org eternalcentre.org"

####################### Separator ########################

check_domain_name(){
if &#91; $1 == $main_domain ];then
	
	ping -c4 -i0.4 $1 | grep $ip &amp;&gt; /dev/null
	if &#91; $? -ne 0 ];then
		echo -e "\033&#91;31m $1 is error !!!!! ip is error !!!!! \033&#91;0m"
	else
		curl $1 | grep $nginx &amp;&gt; /dev/null
		if &#91; $? -ne 0 ];then
			echo -e "\033&#91;31m $1 is error !!!!! software is error !!!!! \033&#91;0m"
		else	
			elinks $1 | grep "$content1" | grep "$content2" &amp;&gt; /dev/null
			if &#91; $? -ne 0 ];then
				echo -e "\033&#91;31m $1 is error !!!!! web is error !!!!! \033&#91;0m"
			else
				echo -e "\033&#91;32m $1 is ok \033&#91;0m"
			fi
		fi
		
	fi
else
	elinks $1 | grep "$content1" | grep "$content2" &amp;&gt; /dev/null
	if &#91; $? -ne 0 ];then
		echo -e "\033&#91;31m $1 is error !!!!! web is error !!!!! \033&#91;0m"
	else
		echo -e "\033&#91;32m $1 is ok \033&#91;0m"
	fi


fi
}

for i in $domain
do
	check_domain_name $i
done</code></pre>
]]></content:encoded>
					
		
		
			</item>
		<item>
		<title>[步骤] Linux 时间同步的设置 （通过 NTP 实现）</title>
		<link>https://eternalcenter-2022-02.github.io/ntp-client/</link>
		
		<dc:creator><![CDATA[Mingyu Zhu]]></dc:creator>
		<pubDate>Sun, 21 Jul 2019 12:40:05 +0000</pubDate>
				<category><![CDATA[Chinese (中文)]]></category>
		<category><![CDATA[NTP]]></category>
		<category><![CDATA[Other Services (其他服务)]]></category>
		<category><![CDATA[Services (服务)]]></category>
		<guid isPermaLink="false">https://eternalcenter-2022-02.github.io/?p=4869</guid>

					<description><![CDATA[注意：从 CentOS 7.2&#38;RHEL 7.0 开始实现时间同步的程序默认从 NTP 换成了 Chrony 。 NTP 也可以继续使用，但是需要单独安装 NTP 的安装包。 步骤一：系统环境要求 服务器系统要配置好可用的软件源 步骤二：确保 NTP 已经安装 步骤三：确保系统会使用 Chrony 或 NTP 的时间同步 步骤四：修改配置文件 将部分内容修改如下： （说明：在配置文件的末尾添加要进行时间同步的服务器） 步骤五：重启客户端的 NTP 服务 步骤六：显示客户端时间同步的状态]]></description>
										<content:encoded><![CDATA[
<p>注意：从 CentOS 7.2&amp;RHEL 7.0 开始实现时间同步的程序默认从 NTP 换成了 Chrony 。 NTP 也可以继续使用，但是需要单独安装 NTP 的安装包。</p>



<h4 id="步骤一-系统环境要求">步骤一：系统环境要求</h4>



<p>服务器系统要配置好可用的软件源</p>



<h4 id="步骤二-确保-ntp-已经安装">步骤二：确保 NTP 已经安装</h4>



<pre class="wp-block-code"><code># yum -y install ntp</code></pre>



<h4 id="步骤三-确保系统会使用-chrony-或-ntp-的时间同步">步骤三：确保系统会使用 Chrony 或 NTP 的时间同步</h4>



<pre class="wp-block-code"><code># timedatectl set-ntp true
# timedatectl
               Local time: Fri 2020-06-12 09:52:30 EDT
           Universal time: Fri 2020-06-12 13:52:30 UTC
                 RTC time: Fri 2020-06-12 13:51:52
                Time zone: America/New_York (EDT, -0400)
System clock synchronized: yes
              NTP service: active
          RTC in local TZ: no</code></pre>



<h4 id="步骤四-修改配置文件">步骤四：修改配置文件</h4>



<pre class="wp-block-code"><code># vim /etc/sysconfig/ntp</code></pre>



<p>将部分内容修改如下：</p>



<pre class="wp-block-code"><code>......
server 0.centos.pool.ntp.org iburst
server 1.centos.pool.ntp.org iburst
server 2.centos.pool.ntp.org iburst
server 3.centos.pool.ntp.org iburst</code></pre>



<p>（说明：在配置文件的末尾添加要进行时间同步的服务器）</p>



<h4 id="步骤五-重启客户端的-ntp-服务">步骤五：重启客户端的 NTP 服务</h4>



<pre class="wp-block-code"><code># service ntpd restart
# service ntpd status</code></pre>



<h4 id="步骤六-显示客户端时间同步的状态">步骤六：显示客户端时间同步的状态</h4>



<pre class="wp-block-code"><code># ntpq -p</code></pre>
]]></content:encoded>
					
		
		
			</item>
	</channel>
</rss>
